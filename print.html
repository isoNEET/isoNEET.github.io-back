<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Study Notes</title>
        <meta name="robots" content="noindex" />

        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/atom-one-dark.min.css">
        <!-- Custom theme stylesheets -->

        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/highlight.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
        <script>mermaid.initialize({startOnLoad:true});</script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">yhchen.space</li><li class="chapter-item expanded "><a href="introduce.html"><strong aria-hidden="true">1.</strong> Introduce</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> 開發工具</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="sections/tools/git.html"><strong aria-hidden="true">2.1.</strong> Git</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.2.</strong> Visual Studio Code</div></li></ol></li><li class="chapter-item expanded "><li class="part-title">WEB 相關知識</li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> </div></li><li><ol class="section"><li class="chapter-item expanded "><a href="sections/related-work/API.html"><strong aria-hidden="true">3.1.</strong> API 與 RESTful API</a></li><li class="chapter-item expanded "><a href="sections/related-work/URL.html"><strong aria-hidden="true">3.2.</strong> URL</a></li><li class="chapter-item expanded "><a href="sections/related-work/HTTP.html"><strong aria-hidden="true">3.3.</strong> HTTP 協定</a></li><li class="chapter-item expanded "><a href="sections/related-work/Secure.html"><strong aria-hidden="true">3.4.</strong> 網頁的基礎安全</a></li><li class="chapter-item expanded "><a href="sections/related-work/CSR_SSR.html"><strong aria-hidden="true">3.5.</strong> 客戶端與伺服端渲染</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">JavaScript Core</li><li class="chapter-item expanded "><a href="sections/js-core/Overview.html"><strong aria-hidden="true">4.</strong> 概觀</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sections/js-core/Syntax.html"><strong aria-hidden="true">4.1.</strong> 1. 語法速覽</a></li><li class="chapter-item expanded "><a href="sections/js-core/Types.html"><strong aria-hidden="true">4.2.</strong> 2. 深入型別系統</a></li><li class="chapter-item expanded "><a href="sections/js-core/Object.html"><strong aria-hidden="true">4.3.</strong> 3. 物件與類別</a></li><li class="chapter-item expanded "><a href="sections/js-core/JS-Arch.html"><strong aria-hidden="true">4.4.</strong> 4. JS引擎架構</a></li><li class="chapter-item expanded "><a href="sections/js-core/Asynchronous.html"><strong aria-hidden="true">4.5.</strong> 5. 非同步程式設計</a></li><li class="chapter-item expanded "><a href="sections/js-core/Common-skill.html"><strong aria-hidden="true">4.6.</strong> 6. 常用技巧與函數</a></li><li class="chapter-item expanded "><a href="sections/js-core/Conclusion.html"><strong aria-hidden="true">4.7.</strong> 7. 總結</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> 附錄</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix/es5-class.html"><strong aria-hidden="true">5.1.</strong> ES5 Class</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Study Notes</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="簡介"><a class="header" href="#簡介">簡介</a></h1>
<p>本文件根據 Gamelab 開發人員的過往經驗，匯集其開發過程的筆記並經過簡單整理後撰寫的</p>
<p>網羅了程式語言、應用開發、學術等各個領域的資料，也包含開發人員常用的技巧分享等</p>
<p>整理過程中，若發現有缺少的資料，也會盡量找到相關資訊並且補上</p>
<p>流程圖大部分使用 <a href="https://www.diagrams.net">https://www.diagrams.net</a></p>
<p>形式上，會透過以下方式分類：</p>
<pre><code class="language-md"># Topic
- Overview
  - section1
  - section2
  - section3
  - section4
    - section4.1
    - section4.2
</code></pre>
<p>Overview 的內容，會補充 Topic 可能會用到的工具、參考資料的統整之類的</p>
<p>Section 的內容，則依照整理者細分主題的各個小單元進行補充</p>
<p>本文件使用 MdBook 撰寫</p>
<h2 id="參考資料"><a class="header" href="#參考資料">參考資料</a></h2>
<p>HTML 基礎語法 - <a href="https://developer.mozilla.org/zh-TW/docs/Web/HTML">https://developer.mozilla.org/zh-TW/docs/Web/HTML</a></p>
<p>CSS 基礎語法 - <a href="https://developer.mozilla.org/zh-TW/docs/Web/CSS">https://developer.mozilla.org/zh-TW/docs/Web/CSS</a></p>
<p>JavaScript 基礎語法 - <a href="https://developer.mozilla.org/zh-TW/docs/Learn/JavaScript/First_steps">https://developer.mozilla.org/zh-TW/docs/Learn/JavaScript/First_steps</a></p>
<p>React 官方文件 - <a href="https://zh-hant.reactjs.org/">https://zh-hant.reactjs.org/</a></p>
<p>WebAPI - <a href="https://developer.mozilla.org/zh-TW/docs/Web/API">https://developer.mozilla.org/zh-TW/docs/Web/API</a></p>
<p>Restful API - <a href="https://docs.microsoft.com/zh-tw/azure/architecture/best-practices/api-design">https://docs.microsoft.com/zh-tw/azure/architecture/best-practices/api-design</a></p>
<p>TypeScript - <a href="https://www.typescriptlang.org/community">https://www.typescriptlang.org/community</a></p>
<p>web.dev - <a href="https://web.dev/learn/">https://web.dev/learn/</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git"><a class="header" href="#git">Git</a></h1>
<p>Git 是一個免費和開源的分佈式版本控制系統，旨在以速度和效率處理從小型到大型項目的所有內容</p>
<blockquote>
<p><em>git</em> 是一個軟體，<em>github, gitlab</em> 是<strong>軟體原始碼代管平台</strong>，使用<em>Git</em> 作為版本控制， <strong>git 不等於 github 或 gitlab</strong></p>
</blockquote>
<h2 id="install"><a class="header" href="#install">Install</a></h2>
<p>請直接到 git 的<a href="https://git-scm.com/">官方網站</a> 進行安裝，如果是 Windows 的使用者，建議可以順便安裝 git-bash 作為終端機使用</p>
<p>他模擬了 Linux 的 Bash，若是同時在 Linux 與 Windows 上都有開發需求的人員，可以統一使用 Bash 的指令</p>
<p><img src="sections/tools/./images/git-bash.png" alt="git-bash" /></p>
<p>此外，也會同時安裝 Git GUI，這工具可以讓使用者使用圖形化介面查看 Git Repos 的資訊</p>
<p><img src="sections/tools/./images/git-gui.png" alt="git-gui" /></p>
<p>不過官方也有推薦其他的工具，比較知名的像是 <code>SourceTree</code> 或是 <code>Github Desktop</code></p>
<p><img src="https://i.imgur.com/DtbMrnO.png" alt="SourceTree" /></p>
<p><img src="https://desktop.github.com/images/github-desktop-screenshot-windows.png" alt="GitHub Desktop" /></p>
<p>各位可以在 Git 的<a href="https://git-scm.com/downloads/guis">客戶端介紹</a> 頁面，看到統整的各個軟體，找到自己喜歡的使用</p>
<p>筆者大部分是使用 cli 以及 Visual Studio Code 內建的 git 功能 + 額外的 plugins，因此沒有安裝 GUI 軟體</p>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<p>官方有非常詳細的 <a href="https://git-scm.com/book/zh-tw/v2">git 指南</a>，因此這邊僅假設你是個新手，列出一些常用的語法</p>
<div class="table-wrapper"><table><thead><tr><th>Command</th><th>作用</th></tr></thead><tbody>
<tr><td>git clone &lt;url&gt;</td><td>複製一個 Repos 到本地端</td></tr>
<tr><td>git init</td><td>在本地端初始化一個Git Repos</td></tr>
<tr><td>git add &lt;pattern&gt;</td><td>追蹤符合&lt;pattern&gt; 的檔案</td></tr>
<tr><td>git status</td><td>列出目前的 Repos 狀態</td></tr>
<tr><td>git diff</td><td>除了列出Repos狀態外，額外列出改變的檔案內容</td></tr>
<tr><td>git commit</td><td>提交一個變更</td></tr>
<tr><td>git log</td><td>檢視 Repos 的歷史紀錄</td></tr>
<tr><td>git remote</td><td>設定遠端的相關資訊</td></tr>
<tr><td>git push &lt;remote&gt; &lt;branch&gt;</td><td>推送變更到指定 Repos 的分支上</td></tr>
<tr><td>git pull</td><td>獲取並合併遠端 Repos 的分支</td></tr>
</tbody></table>
</div>
<p>這裡快速列出了常用的指令，這裡列出幾個情境：</p>
<p>1. 獲取遠端的Repos</p>
<p>舉例來說，如果我想要下載 <a href="https://github.com/torvalds/linux">https://github.com/torvalds/linux</a> 這個儲存庫</p>
<p>若我在 ~/workdir 這個目錄下執行指令：</p>
<pre><code class="language-bash">git clone https://github.com/torvalds/linux
</code></pre>
<p>那麼便會建立 <code>~/workdir/hellogitworld</code> 這個資料夾，裡面有 linux repo 的相關資訊</p>
<p>也可以在 clone 時，指定資料夾：</p>
<pre><code class="language-bash">git clone https://github.com/torvalds/linux linux-kernel
</code></pre>
<p>那麼便會建立 <code>~/workdir/linux-kernel</code> 這個資料夾，裡面有 linux repo 的相關資訊</p>
<p>如果是要下載大型的 Repos 時，可以加上 <code>--depth=1</code> 參數，就只會抓取最新版本的紀錄</p>
<p>2. 建立一個遠端的Repos</p>
<p>比如說我現在於本地端沒有 Repos，我想要建立一個 Repos 並上傳至託管網站(例如 github)</p>
<pre><code class="language-bash">git init
</code></pre>
<p>這會初始化目前的資料夾，作為git 的 Repos。此時可以使用 <code>git stauts</code>，會列出尚未追蹤的檔案</p>
<p>這時候就可以使用 <code>git add</code> 追蹤檔案和 <code>git commit</code> 提交此次變更</p>
<pre><code class="language-bash">git add *.cc    # 追蹤所有附檔名為 ,\.cc 的檔案
git add &lt;name&gt;  # 追蹤 &lt;name&gt; 這個檔案，如果 &lt;name&gt; 是資料夾，追蹤資料夾下的所有文件
git commit -m &quot;message&quot; # 提交變更，並註記資訊 message
git commit -a           # 提交COMMIT_MESSAGE檔案
</code></pre>
<p><code>git add</code> 是使用 <code>GLOB</code> 的格式來匹配檔案的，不過第一次提交通常使用 <code>.gitignore</code> 設定要忽略的檔案，再使用 <code>git add .</code> 追蹤整個專案</p>
<p>最後透過 <code>push</code> 指令，提交首次的變更到遠端上，因為第一次要指定特定的遠端位置，所以須透過 <code>-u</code> 參數來設定</p>
<pre><code class="language-bash">git push -u &lt;remote&gt; &lt;branch&gt;
</code></pre>
<h2 id="與遠端協同工作"><a class="header" href="#與遠端協同工作">與遠端協同工作</a></h2>
<p>在與提交資料到git server之前，必須處理好有關的 git 與 ssh 資訊</p>
<p>如果是 windows 用戶這裡建議使用 <code>powershell</code> 或是 <code>git-bash</code></p>
<p>首先到使用者的家目錄(通常是 c:/Users/&lt;username&gt;)，然後建立 <code>.ssh</code> 資料夾</p>
<p>在該資料夾下，使用指令 <code>ssh-keygen</code></p>
<pre><code class="language-bash">mkdir -p ~/.ssh # 建立 .ssh 資料夾，如果已經存在可以忽略
cd ~/.ssh       # 建立 .ssh 資料夾，如果已經存在可以忽略
ssh-keygen      # 建立 RSA Key-pair，可使用 -t 選擇其他加密法
</code></pre>
<p>接下來會問你生成的金鑰名稱以及 Passphrase，<code>Passphrase</code> 可以忽略沒關係</p>
<p>金鑰名稱若沒有設定，預設會是 <code>id_rsa</code>，或是加密法的名稱，例如使用 <code>-t ed25519</code> 預設名稱就會是 <code>id_25519</code></p>
<p>若使用預設名稱，應該會生成 <code>id_rsa</code> 跟 <code>id_rsa.pub</code> 兩個檔案</p>
<p>接下來，假設你是 <a href="https://github.com">github</a> 用戶，請登入後點擊右上方的圖像，找到 Settings 這個分類，並找到 Access / SSH and GPG Keys 這個選項後，點擊右上方的 <code>New SSH Key</code>，會看到該畫面：</p>
<p><img src="sections/tools/./images/github-settings.png" alt="github-setting" /></p>
<p>Title 可以輸入足夠你辨識的資訊即可；而Key 則輸入 <code>id_rsa.pub</code> 的內容</p>
<p>完成後儲存，回到終端機，嘗試對 github 進行 SSH 登入：</p>
<p><img src="sections/tools/images/git-ssh.png" alt="git-ssh" /></p>
<p>-i 參數是設定使用的金鑰
-T 則是告知 github，不需要分配一個終端機</p>
<p>通常 <code>ssh-keygen</code> 產生的金鑰對都會是 <code>&lt;name&gt;</code> 跟 <code>&lt;name&gt;.pub</code>，分別是私鑰跟公鑰</p>
<p>公鑰提供給 github 或是 gitlab，私鑰則用來登入。上圖中的紅框處，應該要是你的github 名稱</p>
<h2 id="ssh-config"><a class="header" href="#ssh-config">ssh config</a></h2>
<p>如果每次都要這樣處理，會顯得過於麻煩，因此可以使用 ssh config 設定登入資訊</p>
<p>在 <code>~/.ssh</code> 目錄下，建立一個 Config 檔案，內容輸入：</p>
<pre><code class="language-config">Host github
  HostName github.com
  User git
  IdentityFile ~/.ssh/id_rsa
</code></pre>
<p>Host 是供你辨識的連線名稱
HostName 用來設定伺服器的位置，可以是網域或是 ip
User 是登入的用戶名稱
IdentityFile 則是私鑰的檔案位置</p>
<p>當設定好 <code>.ssh/config</code> 的資訊，可以嘗試用 Host 連線，比方說</p>
<pre><code class="language-bash">ssh github
</code></pre>
<p><img src="sections/tools/images/git-sshconfig.png" alt="git-sshconfig" /></p>
<p>就會發現可以順利連線，當然 ssh config 可以設定多組資訊，比方說：</p>
<pre><code class="language-config">Host github-alex
  HostName github.com
  User git
  IdentityFile ~/.ssh/alex

Host github-benson
  HostName github.com
  User git
  IdentityFile ~/.ssh/benson

Host gitlab-howard
  HostName github.com
  User git
  IdentityFile ~/.ssh/howard
</code></pre>
<p>因為本質是用來進行 ssh 登入的，因此也可以設定給 Linux 主機做登入資訊，但是這裡不細談</p>
<p>以上的做法，適用於 windows/linux，範例中使用 github，但是 gitlab也有同樣的機制</p>
<h2 id="與遠端交互"><a class="header" href="#與遠端交互">與遠端交互</a></h2>
<p>最後一個階段，要來設定 git remote，不管在 github 還是 gitlab 上，你的Repos 通常會在 <code>/&lt;username&gt;/&lt;repo-name&gt;</code> 這個路徑，例如前面提到的<code>https://github.com/torvalds/linux</code>，username就是torvalds，repo-name則是linux</p>
<p>因此，若你是Repos的創建者，請先到 github 建立一個repos，假設你的名字叫做<code>foo</code>而且repo-name是<code>bar</code>，那你的repos URL 應該是 <code>https://github.com/foo/bar</code></p>
<p>此時要設定 <code>git remote</code> 的資訊，請使用</p>
<pre><code class="language-bash"># git remote add &lt;name&gt; &lt;url&gt;
git remote add origin https://github.com/foo/bar
</code></pre>
<p>通常 name 會使用 <code>origin</code>，url 則是你的 repo 位置，但是這裡考慮到未來push/pull 會需要驗證，所以建議把 url 改成 ssh config 的資訊，例如</p>
<pre><code class="language-bash">git remote add origin github:foo/bar
</code></pre>
<p>其實在 github，clone 時會給你選 https , ssh , github-cli 三種方式， ssh 給你的URL會是 <code>git@github.com:&lt;username&gt;/&lt;repo&gt;.git</code> 只需要把 ssh config 的 host 替換 <code>git@github.com</code> 即可，這在 gitlab 或是其他託管網站應該都是一樣的</p>
<p>最後使用</p>
<pre><code class="language-bash">git push -u origin master
</code></pre>
<p>把東西推上 origin(= <code>github:foo/bar</code>) 的 master 分支上</p>
<h2 id="開發流程"><a class="header" href="#開發流程">開發流程</a></h2>
<p>因為這個文件是給 git 新手看的文件，因此 merge / branch 等遠端合作的注意事項，建議直接看 <a href="https://docs.gitlab.com/ee/topics/gitlab_flow.html">gitlab Flow</a> 或是 git flow、github flow 等資料</p>
<p>Git Flow 的邏輯是</p>
<ol>
<li>有個主要的分支，比方說 <code>master</code> 或是 <code>release</code> 放置目前運行或是發行出去的版本</li>
<li>同時會有個開發分支 <code>develop</code>，主要的工作會在該分支上進行</li>
<li>有新的需求時，從 <code>develop</code> fork 新的 <code>feature-&lt;name&gt;</code> 分支
<ol>
<li>登入/登出/會員功能 fork <code>feature-authorization</code> 分支</li>
<li>UI優化 fork <code>feature-UI</code> 分支</li>
<li>照片上傳功能 fork <code>feature-photo-upload</code> 分支</li>
</ol>
</li>
<li>完成功能後，merge 回去 <code>develop</code> 分支</li>
<li>當有個BUG需要緊急處理的時候，從 <code>master</code> 分支 fork <code>bugfix</code>
<ol>
<li>一定要從 <code>master</code> 分支 fork，因為<code>develop</code> 分支可能還會有些開發中、不穩定的功能</li>
<li>修復bug完成後，合併到<code>master</code> 跟 <code>develop</code> 分支(若沒有合併回 <code>develop</code>，下個版本進入 <code>master</code> 時，該bug又會出現)</li>
</ol>
</li>
<li>可能會建立 <code>release</code> 分支，通常是上線前的最後測試</li>
</ol>
<p>而 gitlab flow 與 github flow ，都是在此情況下進行簡化/修改，重點都是著重在區分<code>開發中</code> 和 <code>穩定</code> 功能的分支，依照團隊情況使用即可</p>
<h3 id="commit-message"><a class="header" href="#commit-message">Commit Message</a></h3>
<p>如果專案只有你自己一個人，那麼 Commit Message 只要寫你看得懂的格式就好</p>
<p>但是當團隊進行合作時，建議要討論好 commit message 的格式，通常都會拆成</p>
<pre><code class="language-text">&lt;Header&gt; - 摘要本次變更的內容

(option)&lt;Body&gt; - 詳細說明本次變更的內容

(option)&lt;Footer&gt; - 額外的註記
</code></pre>
<p>每個段落都會用 \n 隔開，一個良好的範例是：</p>
<p><img src="sections/tools/images/commit-example.png" alt="commit-example" /></p>
<p>簡單來說，Header作為摘要不要過長； Body則可以描述這次提交你做了什麼；Footer是個可選的區塊，未必要填寫，如果有使用 Redmine 之類的專案管理軟體，可以註記 issue 編號</p>
<p>筆者認為，commit message 未必要寫得非常專業，以 Google 的範例來說，他們的 Header 會分成 <code>chore</code>, <code>deprecate</code>, <code>feat</code>, <code>fix</code>, <code>release</code> 五種</p>
<p>分別去對應</p>
<ul>
<li>chore - 一些自動化/例行的任務之類的</li>
<li>deprecate - 註記一些功能是應該被淘汰的</li>
<li>feat - 新增一個新的功能</li>
<li>fix - 修復一些錯誤或bug</li>
<li>release - 一些與版本有關的註記</li>
</ul>
<p>當然，也有更複雜的區分，例如：</p>
<ul>
<li>feat: 新的功能</li>
<li>fix: 修復錯誤</li>
<li>docs: 程式碼文件相關的修改(CHANGELOG、README、或是其他文件等)</li>
<li>style: 不影響程式的邏輯，調整原始碼(code format, 空格數量、加上遺漏的分號等)</li>
<li>refactor: 不添加新功能或是修復bug的情況，重構程式碼(可能是拆分成更小的模組、又更優美的寫法...等)</li>
<li>perf: 效能改善，或者是添加一些追蹤效能的程式碼</li>
<li>test: 新增測試文件</li>
<li>ci: 對於CI相關設定的調整</li>
</ul>
<p>Header 也可能加上修改的scope，可能是功能/或是某個模組之類的</p>
<p>範例</p>
<pre><code class="language-text">feat($browser): add onUrlChange event (popstate/hashchange/polling)

New $browser event:
- forward popstate event if available
- forward hashchange event if popstate not available
- do polling when neither popstate nor hashchange available

Breaks $browser.onHashChange, which was removed (use onUrlChange instead)
</code></pre>
<pre><code class="language-text">fix($compile): add unit tests for IE9

Older IEs serialize html uppercased, but IE9 does not...
Would be better to expect case insensitive, unfortunately jasmine does
not allow to user regexps for throw expectations.

Closes #392
Breaks foo.bar api, foo.baz should be used instead
</code></pre>
<p>這樣在 <code>git log --oneline</code> 時，可以清楚看到如：</p>
<pre><code class="language-text">2d0e1ea feat($browser): add onUrlChange event (popstate/hashchange/polling)
a2cc062 fix($compile): add unit tests for IE9
3f1cbb7 feat(directive): add directives disabled/checked/multiple/readonly/selected
e717ffc style($location): add couple of missing semi colons
b62050d docs(guide): update fixed docs from Google Docs
ea303d0 feat($compile): simplify isolate scope bindings
7f5cdfc initial commit
</code></pre>
<p>而當透過 <code>git log</code> 查看紀錄的時候，更快速檢閱相關的變更</p>
<p>反過來說，如果哪天需要追查特定的bug，或是想理解軟體開發脈絡的時候，看到如下的紀錄：</p>
<pre><code class="language-text">2d0e1ea update
a2cc062 commit
3f1cbb7 fix
e717ffc commit
b62050d update
ea303d0 update
7f5cdfc initial commit
</code></pre>
<p>看起來很荒謬對吧？ <strong>但是這樣寫的人其實很多</strong>，這才是最可怕的事情</p>
<p>Body 跟 Footer 先不論，甚至有沒有寫先不管，至少在 Header 的部分，要好好摘要你做了哪些事情</p>
<p>因此希望各位，至少先從&quot;寫好 commit&quot; 這件事情開始學</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="什麼是api"><a class="header" href="#什麼是api">什麼是API</a></h1>
<p>本章節的一開始，首先要釐清 API 的意思。API - Application Programming Interface</p>
<p>其代表的意義為應用程式的互動介面，Protocol、函式簽章等，寬鬆意義上也可以說是 API</p>
<p>而另一方面的意義，則是<strong>程式設計</strong>的相關實作</p>
<p>舉例來說：</p>
<ul>
<li>需要使用 OpenGL 繪製，會使用到 <code>gl[FunctionName]</code>
<ul>
<li>glVertex2f、glBegin、glEnd ... 等</li>
</ul>
</li>
<li>透過URL抓取資料，比方說：<code>http://www.example.com/data</code></li>
<li>調用System Call，如 C 語言的 <code>#include&lt;sys/*.h&gt;</code> 等</li>
</ul>
<p>重點在於<code>介面 interface</code>，從資料結構、常數、函式，到圖形化介面的按鈕</p>
<p>比方說同樣使用Postgresql資料庫，可以寫一個JavaScript程式碼：</p>
<pre><code class="language-js">const { appendFileSync } = require('fs');
const { Client } = require('pg');

const conf = {/* Database connection infomation */}

const client = new Client(conf);

const command = `SELECT * FROM datas`;

client
  .query(command)
  .then({ rows } =&gt; {
    const transfromData = rows.map( row =&gt; JSON.stringify(row));
    appendFileSync('data.json', transfromData);
    process.exit();
  });
</code></pre>
<p>或者使用 shell 去存取：</p>
<pre><code class="language-sh">
psql -d mydatabase -U user --password


psql (12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
Type &quot;help&quot; for help.

user=# SELECT * FROM datas;
</code></pre>
<p>或許透過不同的方式去存取資料庫，但是最終目的都是 <code>從某個地方把資料讀出來</code>，而資料庫則是提供了客戶端的程式<code>psql</code> 或是相關的函式庫(<code>libpg</code>)</p>
<p>針對特定功能，提供一系列操作的介面，就是 API 的本質</p>
<p><strong>Note!</strong> 請注意，重點是介面</p>
<p>比方說 <code>Firefox</code> 與 <code>Chrome</code> 都有 <code>console.log</code> 來輸出一些資料在 DevTools 上
他們內部的實現不一定是相同的，但都可以用 <code>console.log</code> 做到這件事情</p>
<h2 id="interface-至關重要"><a class="header" href="#interface-至關重要">Interface 至關重要</a></h2>
<p>介面的概念非常重要，因為介面<strong>隱藏了細節</strong>，以生活的例子來說：</p>
<p>無論是電腦、電視、手機充電器、微波爐 ... 等家具，都可以統一透過 110V 或是 220V 的插座使用</p>
<p>也許他們的功率分別是 700W、300W、65W、1200W，但是對於電源輸入的介面，所有的電器大抵上都是相同的</p>
<p>而對於程式的設計，介面的重要性有幾點：</p>
<ol>
<li>對於第三方開發人員來說，他隱藏了內部的實現，僅把操作的函式暴露出去</li>
<li>對於使用者來說，提供了大致相同的操作方法</li>
<li>對於模組的規畫人員，提供了一個好的設計模式</li>
</ol>
<p>對於1、2點，算是非常直白，因此這裡著重在第3點</p>
<h3 id="介面隔離原則--依賴反轉原則"><a class="header" href="#介面隔離原則--依賴反轉原則">介面隔離原則 &amp; 依賴反轉原則</a></h3>
<p>雖然設計模式的理解在程式碼的開發上也相當重要，但是這裡不打算細談，只會提出這兩個重要的原則：</p>
<p>介面隔離原則 Interface Segregation Principle</p>
<blockquote>
<p>拆分非常龐大臃腫的介面成為更小的和更具體的介面，這樣客戶將會只需要知道他們感興趣的方法
從而容易重構，更改和重新部署</p>
</blockquote>
<p>依賴反轉原則 Dependency inversion principle</p>
<blockquote>
<p>高層次的模組，不應該依賴於底層的模組，而是依賴於抽象介面；以及，抽象介面不應該依賴於具體實現。而具體實現則應該依賴於抽象介面</p>
</blockquote>
<p>這裡把兩個原則同時提出，以下舉出兩個例子：</p>
<p>倘若我是資料庫的開發人員，早期階段只有磁碟機時，做出以下規劃：</p>
<pre><code class="language-cpp">class HardDisk {
public: 
  void write(char* content);
  void read(char* filename);
  /* more member */
}
</code></pre>
<p>現在，處理好了設備的處理函式，接下來實現資料庫本身的邏輯：</p>
<pre><code class="language-cpp">class DataBase {
public:
  int connect(const std::string user, const std::string password);
  void load(HardDisk disk);
  void store(HardDisk disk);
  /* more member */
}

// 成員可能的實作：
void DataBase::load(HardDisk disk) {
  /* 根據連線資訊以及查詢指令，匹配索引、資料庫、資料表等 */
  disk.read(filename);
}

void DataBase::store(HardDisk disk) {
  /* 建立 BTree、檢查索引、資料型別、格式化等 */
  disk.write(content);
}
</code></pre>
<p>這看起來很不錯對嗎？但是隨著時間過去，有了更多設備，比方說SSD：</p>
<pre><code class="language-cpp">
class SolidStateDisk {
public: 
  void write(char* content);
  void read(char* filename);
  /* more member */
}

class DataBase {
public:
  int connect(const std::string user, const std::string password);
  void load(HardDisk disk);
  void store(HardDisk disk);

  // function overload
  void load(SolidStateDisk disk);
  void store(SolidStateDisk disk);
  /* more member */
}
</code></pre>
<p>好的，現在解決了問題，但是新的問題又出現了：SSD又分成PCIe、SATA、M.2 等介面，於是可能會新增：</p>
<pre><code class="language-cpp">class SolidStateDisk_SATA {}
class SolidStateDisk_PCIe {}
class SolidStateDisk_M2 {}
</code></pre>
<p>而在 <code>Database</code> 類別中，則要擴充更多成員函式，這顯然會導致程式碼越來越難以維護...</p>
<p>這時候依照<strong>依賴反轉原則</strong>：</p>
<ul>
<li>高層次的模組，不應該依賴於底層的模組</li>
<li>以及，抽象介面不應該依賴於具體實現</li>
<li>具體實現則應該依賴於抽象介面</li>
</ul>
<p>首先釐清高層次與底層次的模組，簡單來說，越接近應用層(或是說<em>商業邏輯</em>)，就相對高階</p>
<blockquote>
<p>DataBase 是高層次的；HardDisk 是低層次的</p>
</blockquote>
<p>其次，高階的模組不應該依賴於低層次的模組，也就是說這種設計方式是有問題的</p>
<pre><code class="language-cpp">class DataBase {
public:
  int connect(const std::string user, const std::string password);
  void load(HardDisk disk);
  void store(HardDisk disk);
  void load(SolidStateDisk disk);
  void store(SolidStateDisk disk);
  /* more member */
}
</code></pre>
<p>處理的方式有很多種，但是具體來說，有個明確的目標：減少 DataBase 的依賴性</p>
<p>可以先提出一個<strong>高階</strong>介面，且不提供具體的實現，比方說</p>
<pre><code class="language-cpp">class IO_Device {
public:
  virtual void write(char* content) = 0;
  virtual void read(char* filename) = 0;
}
</code></pre>
<p>接下來，移轉高階模組的依賴：</p>
<pre><code class="language-cpp">class DataBase {
public:
  int connect(const std::string user, const std::string password);
  // 依賴於 IO_Device 介面
  void load(IO_Device disk);
  void store(IO_Device disk);

  // void load(HardDisk disk);
  // void store(HardDisk disk);
  // void load(SolidStateDisk disk);
  // void store(SolidStateDisk disk);
  /* more member */
}
</code></pre>
<p>最後，修改低階模組的宣告，使其必須實現高階介面：</p>
<pre><code class="language-cpp">class HardDisk: public IO_Device {}
class SolidStateDisk_SATA: public IO_Device {}
class SolidStateDisk_PCIe: public IO_Device {}
class SolidStateDisk_M2: public IO_Device {}
</code></pre>
<p>回頭來看的目標：</p>
<ul>
<li>高層次的模組，不應該依賴於底層的模組：DataBase 現在依賴於 <code>IO_Device</code> 之上</li>
<li>以及，抽象介面不應該依賴於具體實現：<code>IO_Device</code>並未提供實作，而是交由底層的模組實現</li>
<li>具體實現則應該依賴於抽象介面：<code>HardDisk</code>與<code>SolidStateDisk</code> 繼承 Pure Virtual Function <code>write</code> 與 <code>read</code></li>
</ul>
<p>倘若未來，想要再加入新的儲存媒介，比方說使用記憶體 <code>RAMDisk</code>：</p>
<pre><code class="language-cpp">// 倘若未繼承 IO_Device，便無法提供給 Database類別使用
class RAMDisk : public IO_Device {
  // 因為繼承了 IO_Device，必須實作兩個虛擬函式
  void write(char* content);
  void read(char* filename);
}
</code></pre>
<p>以上是一個很經典的例子，另外一個例子式 C++ 的 STL，試想一下：</p>
<p>有許多需要操作的容器，以一維容器來說，有 <code>vector</code>、<code>list</code>、<code>queue</code>、<code>stack</code> 等</p>
<p>假設他們都有排序的需求，實作有可能有兩種情況：</p>
<pre><code class="language-cpp">void sort(std::vector, int startIndex, int endIndex);
void sort(std::list, int startIndex, int endIndex);
void sort(std::queue, int startIndex, int endIndex);
void sort(std::stack, int startIndex, int endIndex);

sort(vec, 0, vec.size() -1 );
</code></pre>
<p>或者是依賴於迭代器(Iterator)介面</p>
<pre><code class="language-cpp">template&lt;typename T&gt;
class Iterator&lt;T&gt; {
public:
  virtual T* begin() = 0;
  virtual T* end() = 0;
  virtual operator--();
  virtual operator++();
}

/* Impl interface Iterator&lt;T&gt; */
template&lt;typename T&gt; class std::vector&lt;T&gt; : public Iterator&lt;T&gt;{}
template&lt;typename T&gt; class std::list&lt;T&gt; : public Iterator&lt;T&gt;{}
template&lt;typename T&gt; class std::queue&lt;T&gt; : public Iterator&lt;T&gt;{}
template&lt;typename T&gt; class std::stack&lt;T&gt; : public Iterator&lt;T&gt;{}

// function signature
void sort(Iterator&lt;T&gt;, Iterator&lt;T&gt;);

sort(vec.begin(), vec.end());
</code></pre>
<p>各位可以思考看看，哪一個才是可能的實現</p>
<p>在撰寫程式的過程中，多思考看看的介面的意義：</p>
<ul>
<li>使用者如何調用</li>
<li>模組之間的依賴關係</li>
<li>程式碼中的抽象與實現</li>
</ul>
<p>再提出一個例子，比方說今天我是 <em>STEAM</em> 上遊戲的開發人員，我希望我的遊戲可以下載 Plugin</p>
<p>但是這麼多第三方人員，要如何規範他們呢？</p>
<p>能不能提出一個基礎類別：</p>
<pre><code class="language-ts">interface Plugin {
  init()
  load()
  disable()
}
</code></pre>
<p>並規範所有 Plugin 的開發人員遵守呢？</p>
<h2 id="restful"><a class="header" href="#restful">RESTful</a></h2>
<p>內容是參考以下網站，並根據開發人員的經驗摘要，可能會與網路上的一些資訊有出入</p>
<p><a href="https://www.restapitutorial.com/">https://www.restapitutorial.com/</a>、<a href="https://restcookbook.com/">https://restcookbook.com/</a></p>
<p>筆者推薦的內容，則是 Mircosoft 撰寫的<a href="https://docs.microsoft.com/zh-tw/azure/architecture/best-practices/index-best-practices">雲端應用程式中的最佳做法</a></p>
<p>這裡先提一個懶人包： <em>API 不等於 RESTful API</em>，RESTful API 只是一種 API 風格而已，<em>不是規範</em></p>
<h2 id="前言"><a class="header" href="#前言">前言</a></h2>
<p>再談論 RESTful API 之前，先簡單說明一下現今的 Web App 所需的 API 會有幾個特色：</p>
<ul>
<li>平台獨立</li>
<li>服務迭代</li>
</ul>
<p><strong>平台獨立</strong>的意思是，不論 API 的內部如何實作，都應該可以透過公開的、標準的協議進行存取</p>
<p>好比說有個註冊帳號 API，對於客戶端來說，不必在乎他是使用什麼程式語言開發的，也不用知道使用什麼作業系統開發的</p>
<p>只要依照某種標準協議 <code>Ex. HTTP</code>，就可以讓用戶端與Web服務進行資料交換</p>
<p><strong>服務迭代</strong>的概念是，客戶端與服務端是分開的</p>
<p>伺服器端的服務會不斷迭代更新並且新增功能，而隨著服務端的更新，客戶端應該要不進行修改，依然可以順利運作</p>
<p>我認為的意義是這樣：舉例來說，今日有個訂餐系統，會上傳餐點的編號，如 <code>GHR201</code> 之類的</p>
<p>而原先的程式設計如下：</p>
<pre><code class="language-js">async function order(foodId) {
  const data = await fetch(apiEndpoint, {
    headers: { 'Content-type': 'application/json' },
    method: 'post',
    body: JSON.stringify({ foodId });
  }).then(res =&gt; res.json());
  console.log( data ) /* 內容可能為
    {
      foodId: 'GHR201',
      name: '肉絲炒飯',
      price: 60
    }
  */

  dosomething(data) // 可能會客戶端的畫面顯示&quot;下訂成功&quot; 還有相關資訊
}
</code></pre>
<p>但是假設伺服端的回應修改了，例如：</p>
<pre><code class="language-json">{
  &quot;uniqueId&quot;: &quot;GHR201&quot;,
  &quot;foodName&quot;: &quot;肉絲炒飯&quot;,
  &quot;orderTime&quot;: &quot;14:19&quot;,
  &quot;expectTime&quot;: 1200
}
</code></pre>
<p>看起來多出了 &quot;下訂的時間&quot; 與 &quot;預期送達時間&quot;，像是 14:19 下訂，20分鐘後左右會送到</p>
<p>但是 &quot;name&quot; 欄位被移除了，修改為 &quot;foodName&quot;，這可能導致客戶端的程式無法順利運作</p>
<p>對於伺服端來說，<strong>盡可能使得客戶端的輸入/輸出不需要額外的變動</strong>，就是服務迭代的概念</p>
<h2 id="soap早期的api實現"><a class="header" href="#soap早期的api實現">SOAP(早期的API實現)</a></h2>
<p>上個章節大概理清了：伺服器與客戶端需要有資料交換的機制，且最好是與實作隔離</p>
<p>僅依賴在某種協定之上，因此早期衍生出了 SOAP(Simple Object Access Protocol)</p>
<p>透過把 SOAP 繫結到 HTTP，同時利用了SOAP與HTTP的優點</p>
<p>在HTTP上傳送SOAP並不意味著SOAP會覆蓋現有的HTTP語意，而是HTTP上的SOAP語意會自然地對映到HTTP語意</p>
<p>在使用HTTP作為協定繫結的場合中，RPC請求對映到HTTP請求上，而RPC應答對映到HTTP應答。然而，在RPC上使用SOAP並不僅限於HTTP協定繫結</p>
<p>由 SOAP 發出的請求內容可能會是：</p>
<pre><code class="language-xml">&lt;soapenv:Envelope
  xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;
  xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;
  &lt;soapenv:Body&gt;
    &lt;req:echo xmlns:req=&quot;http://localhost:8080/wxyc/login.do&quot;&gt;
      &lt;req:category&gt;classifieds&lt;/req:category&gt;
    &lt;/req:echo&gt;
  &lt;/soapenv:Body&gt;
&lt;/soapenv:Envelope&gt;
</code></pre>
<p>而收到的回應可能會是：</p>
<pre><code class="language-xml">&lt;soapenv:Envelope
  xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;
  xmlns:wsa=&quot;http://schemas.xmlsoap.org/ws/2004/08/addressing&quot;&gt;
  &lt;soapenv:Header&gt;
    &lt;wsa:ReplyTo&gt;
      &lt;wsa:Address&gt;http://schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous&lt;/wsa:Address&gt;
    &lt;/wsa:ReplyTo&gt;
    &lt;wsa:From&gt;
      &lt;wsa:Address&gt;http://localhost:8080/axis2/services/MyService&lt;/wsa:Address&gt;
    &lt;/wsa:From&gt;
    &lt;wsa:MessageID&gt;ECE5B3F187F29D28BC11433905662036&lt;/wsa:MessageID&gt;
  &lt;/soapenv:Header&gt;
  &lt;soapenv:Body&gt;
    &lt;req:echo xmlns:req=&quot;http://localhost:8080/axis2/services/MyService/&quot;&gt;
      &lt;req:category&gt;classifieds&lt;/req:category&gt;
    &lt;/req:echo&gt;
  &lt;/soapenv:Body&gt;
&lt;/soapenv:Envelope&gt;
</code></pre>
<h2 id="rest"><a class="header" href="#rest">REST</a></h2>
<p>在 2000 年時，Roy Fielding 提出了以具象狀態傳輸(REST)的架構來設計 Web 服務</p>
<p>REST 全稱 <strong>REpresentational State Transfer</strong>，是一種<strong>設計風格</strong>，請注意，是設計風格</p>
<p>而不是標準或是協議，相較 SOAP，REST 有幾個重要的特徵：</p>
<ul>
<li>Uniform Interface</li>
<li>Stateless</li>
<li>Cacheable</li>
</ul>
<p>和 SOPA 或是 XML-RPC 相比之下，REST顯得相對簡單，並且善用了 HTTP 的語意機制</p>
<p>除此之外，也不局限於XML，JSON、YAML等格式，都可作為資源的表達</p>
<p>重點在於 <strong>資源的表達</strong></p>
<ul>
<li>透過 URI 來指定存取的資源</li>
<li>針對資源，常需要進行CRUD(Create, Read, Update, Delete)，剛好可對應到 HTTP Method</li>
<li>通過資源的表現形式來操作資源</li>
</ul>
<p>大部分的實例，都會通過 HTTP 設計 REST 風格的 API，大致原則如下：</p>
<h3 id="rest-api-是依照資源來設計"><a class="header" href="#rest-api-是依照資源來設計">REST API 是依照資源來設計</a></h3>
<p>架設今天有查詢餐廳訂單的API，可能會是以下形式：</p>
<pre><code class="language-sh">http://example.com/orders
</code></pre>
<p>並且可以透過「識別碼」，存取特定的資源</p>
<pre><code class="language-sh">http://example.com/orders/1
</code></pre>
<p>並且會透過交換資源的表示法，與服務進行互動</p>
<pre><code class="language-json">{
    &quot;orderID&quot;:3,
    &quot;productID&quot;:2,
    &quot;quantity&quot;:4,
    &quot;orderValue&quot;:16.60
}
</code></pre>
<p>而統一的介面，通常指的就是 HTTP 協議，並透過常見的 HTTP Method 來分割 API
如 GET、POST、PUT、PATCH、DELETE 等方法</p>
<p>而 REST API 盡可能要求無狀態，所有的HTTP要求應該是獨立的，並且可能會以任何順序發生</p>
<blockquote>
<p>這裡不好說明&quot;無狀態的&quot;HTTP是什麼意思，因此反過來舉例包含狀態的HTTP：
像是常見的購物車系統，今天在某個電商網站加入物品至購物車中，關閉網頁後，下次訪問還是知道購物車的內容；
或是某個網站，如果以前登入過了，就直接導向到會員頁面，反之則是導向登入介面
以上兩個例子，都是包含狀態性的HTTP請求</p>
</blockquote>
<hr />
<p>接下來，直接看可能實作的 REST API 實例：</p>
<p>比方說電子商務系統中，客戶與訂單的關係</p>
<p>可以透過包含訂單資訊的 POST API 建立訂單，HTTP 回應成功與否</p>
<pre><code class="language-sh">https://adventure-works.com/orders // Good

https://adventure-works.com/create-order // Avoid
</code></pre>
<p>前面有提到，REST 傾向於使用 HTTP Method 描述行為，因此 URI 不應包含動詞(create-order)，應該僅包含資源</p>
<p>要注意的事情是，REST 不是單純反映資料庫內部結構的API，最終目的在於把實體與資源模型化</p>
<p>當然有很多REST的最佳做法，但是暫且不提，最後總結一下常用的方法與例子</p>
<div class="table-wrapper"><table><thead><tr><th>URI</th><th>POST</th><th>GET</th><th>PUT</th><th>DELETE</th></tr></thead><tbody>
<tr><td>/customers</td><td>建立新客戶</td><td>取得所有客戶</td><td>大量更新客戶</td><td>刪除所有用戶</td></tr>
<tr><td>/customers/{id}</td><td>-</td><td>擷取 {id} 的客戶資料</td><td>更新 {id} 的客戶資料</td><td>刪除 {id} 的客戶資料</td></tr>
<tr><td>/customers/{id}/order</td><td>為客戶 {id} 建立訂單</td><td>擷取 {id} 客戶的所有訂單</td><td>更新 {id} 的客戶訂單</td><td>刪除 {id} 的客戶訂單</td></tr>
</tbody></table>
</div>
<p>這只是其中幾個例子，這裡建議可以看看 <a href="https://ptx.transportdata.tw/MOTC/#/CityBus">MOTC API</a>的真實案例</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="url"><a class="header" href="#url">URL</a></h1>
<p>在討論 URL 之前，先來看常見的三個定義：</p>
<ul>
<li>URI - Uniform Resource Identifier，意指用於標識某一網際網路資源名稱的字串</li>
<li>URL - Uniform Resource Locator，俗稱網頁位址，簡稱網址，是網際網路上標準的資源的位址</li>
<li>URN - Uniform Resource Name，期望為資源提供持久的、位置無關的標識方式</li>
</ul>
<p>大概可以理解為 URI = URL + URN，這裡不深入探討三者的差異</p>
<p>但是以現今的用法來說，URI 可以看作和 URL 等價，URN 則是獨立的用法</p>
<ul>
<li><a href="https://www.rfc-editor.org/rfc/rfc2141">URN RFC2141</a></li>
</ul>
<h2 id="url-的形式"><a class="header" href="#url-的形式">URL 的形式</a></h2>
<p>URL 通常會表現為如下的形式：</p>
<pre><code class="language-sh">                    hierarchical part
        ┌───────────────────┴─────────────────────┐
                    authority               path
        ┌───────────────┴───────────────┐┌───┴────┐
  abc://username:password@example.com:123/path/data?key=value&amp;key2=value2#fragid1
  └┬┘   └───────┬───────┘ └────┬────┘ └┬┘           └─────────┬─────────┘ └──┬──┘
scheme  user information     host     port                  query         fragment
</code></pre>
<p>在該例子中：</p>
<ul>
<li>abc 是協定名稱</li>
<li>username 是用戶</li>
<li>password 是密碼</li>
<li>example.com 是網域</li>
<li>123 是連線的 port</li>
<li>/path/data 是路徑</li>
<li>?key=value&amp;key2=vale2 是查詢字串</li>
<li>fragid1 是 fragment</li>
</ul>
<p>而常見的</p>
<pre><code>https://www.google.com
</code></pre>
<p>若未指定通訊埠(之後都稱 port )，http 使用 80 port，https 使用 443 port</p>
<p>請注意，URL 不一定只用在 HTTP 協議上，比方說 mysql 或是 postgresql 可以使用 URL 的方式登入</p>
<ul>
<li>用戶名稱為 Nero</li>
<li>密碼為 a1234qwer</li>
<li>伺服器位於 test.database.cc 所指向的 IP</li>
<li>使用 5432 port</li>
<li>資料庫名稱為 mydatabase</li>
</ul>
<p>那個可以使用</p>
<pre><code>postgresql://Nero:a1234qwer@test.database.cc:5432/mydatabase
</code></pre>
<p>或是加上 Query 參數，設定額外的資訊，如</p>
<pre><code>postgresql://Nero:a1234qwer@test.database.cc:5432/mydatabase?connect_timeout=10&amp;application_name=myapp
</code></pre>
<p>而 username 和 password，實務上比較少用到，但是如果你想嘗試的話，可以透過這種方法驗證：</p>
<ul>
<li>在 github 或是 gitlab 上開啟 Repo，並提交 initial commit</li>
<li>git clone 該 repo</li>
<li>git push，此時終端機會請你輸入帳號、密碼</li>
<li>中止上個階段</li>
<li>使用指令 <code>git remote set-url origin https://[username]:[password]@github.com/&lt;repo&gt;</code></li>
<li>再次嘗試 push，此時不必輸入帳號、密碼就可以完成驗證</li>
</ul>
<h2 id="跟-url-有關的-api"><a class="header" href="#跟-url-有關的-api">跟 URL 有關的 API</a></h2>
<p>在瀏覽器中，有個<code>URL</code>物件，可以用來解析基於 HTTPS 和 HTTP 的 URL</p>
<pre><code class="language-js">const str = &quot;https://abc:passwd@dev.yhchen.monster?key=1&amp;v=2#test&quot;
const url = new URL(str); /* 
{
  hash: &quot;#test&quot;
  host: &quot;dev.yhchen.monster&quot;
  hostname: &quot;dev.yhchen.monster&quot;
  href: &quot;https://abc:passwd@dev.yhchen.monster/?key=1&amp;v=2#test&quot;
  origin: &quot;https://dev.yhchen.monster&quot;
  password: &quot;passwd&quot;
  pathname: &quot;/&quot;
  port: &quot;&quot;
  protocol: &quot;https:&quot;
  search: &quot;?key=1&amp;v=2&quot;
  searchParams: URLSearchParams {}
  username: &quot;abc&quot;
}
*/
</code></pre>
<ul>
<li><code>host</code> 與 <code>hostname</code> 有微小的差異，出現在含有 port 的時候
<ul>
<li>host 包含 domain name + port，例如 <code>localhost:8080</code></li>
<li>hostname 僅包含 domain name，例如 <code>localhost</code></li>
</ul>
</li>
<li><code>origin</code> 包含了 protocol + host，比方說 <code>https://localhost:8080</code></li>
<li><code>href</code> 意思是指 <code>hyper refer</code>超連結，就是原本的輸入</li>
<li><code>search</code> 包含了 <code>?</code> 還有之後的Query</li>
<li><code>hash</code> 包含了 <code>#</code> 還有之後的Fragment</li>
</ul>
<p>通常來說，查詢字串的形式為<code>key=value</code>，並透過<code>&amp;</code> 連結起來</p>
<p>可以用複雜一點的作法來 parse 查詢字串：</p>
<pre><code class="language-js">const str = &quot;https://dev.yhchen.monster?key=1&amp;v=2&amp;g=25&amp;k=40&quot;
const url = new URL(str);
const query = url.search;
const entries = query.slice(1).split('&amp;').map(token =&gt; token.split('='))
const queryObj = Object.fromEntries(entries);
</code></pre>
<p>不過各位學員其實可以注意到，<code>URL</code>物件有提供 <code>searchParams</code> 這個物件，他提供了一些實用的方法</p>
<p>假設現在有個複雜一點的 Query String：</p>
<pre><code>?key=1&amp;v=2&amp;g=25&amp;k=40&amp;qe=hello
</code></pre>
<p>透過以下的方法：</p>
<pre><code class="language-js">
/* ... parse 結束 */
const params = URL.searchParams;

/* 迭代器家族 */
[...params.keys()] // result: ['key', 'v', 'g', 'k', 'qe']
[...params.values()] // result: ['1', '2', '25', '40', 'hello']
[...params.entries()] /* result: 
  [
      [&quot;key&quot;,&quot;1&quot;],
      [&quot;v&quot;,&quot;2&quot;],
      [&quot;g&quot;,&quot;25&quot;],
      [&quot;k&quot;,&quot;40&quot;],
      [&quot;qe&quot;,&quot;hello&quot;]
  ]
*/

/* 設值器 */
params.append('test', 'string');
// url.search: &quot;?key=1&amp;v=2&amp;g=25&amp;k=40&amp;qe=hello&amp;test=string&quot;

params.append('test', 'test');
// url.search: &quot;?key=1&amp;v=2&amp;g=25&amp;k=40&amp;qe=hello&amp;test=string&amp;test=test&quot;

/* 取值器 */
params.get('key') // result: 1
params.getAll('test') // result: ['string', 'test']
params.get('test') // 取出第一個 result: 'string'

/* 覆蓋 &amp; 刪除 */
params.set('test', '0')
// url.search: &quot;?key=1&amp;v=2&amp;g=25&amp;k=40&amp;qe=hello&amp;test=0&quot;

params.delete('test')
// url.search: &quot;?key=1&amp;v=2&amp;g=25&amp;k=40&amp;qe=hello&quot;
</code></pre>
<p>同時，可以透過 <code>location.href</code> 取得目前的網址</p>
<p>至於 <code>Fragment</code>，是比較特殊的用法，在之後幾個章節在說明</p>
<h2 id="相對與絕對路徑"><a class="header" href="#相對與絕對路徑">相對與絕對路徑</a></h2>
<p>之前有提到過，會透過 <code>fetch</code> API 抓取遠端的資料，並且假定目前的網址為</p>
<pre><code>https://www.example.com/docs/page/URL-intro
</code></pre>
<p>而 API 的端點位於 <code>https://www.example.com/api/datas</code>：</p>
<pre><code class="language-js">fetch(&quot;api/datas&quot;) // Errors

fetch(&quot;/api/datas&quot;) // It Works!
</code></pre>
<p>原因在於，一開始的<code>/</code> 會改變 URL 的參照，使用 <code>/</code> 發出的請求，會以 <code>origin</code> 作為 Base</p>
<p>而沒有使用 <code>/</code>，則是以當前路徑作為參照點：</p>
<pre><code class="language-js">// Current Location: https://www.example.com/docs/page/URL-intro

fetch(&quot;api/datas&quot;) // 請求的URL為 https://www.example.com/docs/page/api/datas

fetch(&quot;/api/datas&quot;) // 請求的URL為 https://www.example.com/api/datas
</code></pre>
<p>這是一個需要注意的地方</p>
<h2 id="章節回顧"><a class="header" href="#章節回顧">章節回顧</a></h2>
<p>該章節僅需要知道 URL 的構成語法，以及瀏覽器中與 URL 有關的 API 即可</p>
<ul>
<li>URL 的組成</li>
<li><code>URL</code> 物件與 <code>location.href</code></li>
<li>發出Request時，相對路徑與絕對路徑的差異</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http"><a class="header" href="#http">HTTP</a></h1>
<p><img src="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview/fetching_a_page.png" alt="HTTP" /></p>
<p>HTTP 全名為 <code>Hyper Text Transfer Protocol</code> 超文字傳輸協定</p>
<p>紀錄於 <a href="https://www.rfc-editor.org/rfc/rfc2616.html">RFC 2616</a></p>
<p>以及衍生的 HTTPS、HTTP/2 等協定</p>
<p>相信各位在計算機網路概論都有學習過該協定的內容，因此這裡只會進行一些補充</p>
<p>以及一些伺服器相關的實作</p>
<p>請注意，如 HTTP Pipeline 之類的細節不在本章範疇，預設你已經在計算機網路概論學習過了</p>
<h2 id="user-agent"><a class="header" href="#user-agent">User-agent</a></h2>
<p>泛指能夠發出請求的工具，通常由瀏覽器協助處理。而一些情況下，如開發人員的Debugger、爬蟲腳本等，也算是 User-agent</p>
<p>由瀏覽器發出的請求，通常會受到一些限制(不像自己撰寫的Request 那麼自由)，常見的工具有</p>
<ul>
<li>curl</li>
<li>wget</li>
<li>python、javascript、php 的腳本</li>
</ul>
<p>那在 linux 系統上，還有如 <code>nc</code> 等工具，可以建立 Raw TCP 連線，輸入 HTTP 請求文：</p>
<p><img src="sections/related-work/./images/nc.png" alt="netcat" /></p>
<h2 id="http-請求格式"><a class="header" href="#http-請求格式">HTTP 請求格式</a></h2>
<p><img src="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview/http_request.png" alt="Request" /></p>
<p>請求會由以下幾個元素組合而成：</p>
<ul>
<li>HTTP 動詞</li>
<li>請求路徑</li>
<li>HTTP 協議版本</li>
<li>headers</li>
<li>請求內容</li>
</ul>
<p>HTTP 的 Header 可以見 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers">MDN: HTTP Headers</a></p>
<p>這裡只提幾個重要且常見的 Header:</p>
<ul>
<li>Authorization：添加認證資訊</li>
<li>Content-type：告知接收方，請求內容的格式</li>
<li>X-*：自定義的表頭</li>
</ul>
<p>這裡特別要提及的是 <code>Content-type</code>，在REST 章節中，有強調<code>資源的表達</code>，就是透過該表頭</p>
<p>比方說 JSON 格式的資料，會透過 <code>content-type: application/json</code></p>
<p>一般的表單提交，通常會會是 <code>application/x-www-form-urlencoded</code> 或是 <code>multioart/form-data</code></p>
<p>在以前，比較少處理檔案的提交，因此使用 <code>application/x-www-form-urlencoded</code> 即可，他會把表單用類似 Query String 的方式封裝</p>
<p>如果有個表單要輸入：帳號、密碼、電子信箱，那封裝後的資料格式為</p>
<pre><code class="language-conf">account=myacc&amp;password=a12345678&amp;mail=user@example.com
</code></pre>
<h2 id="http-回應格式"><a class="header" href="#http-回應格式">HTTP 回應格式</a></h2>
<p><img src="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview/http_response.png" alt="Response" /></p>
<p>響應內容會由以下幾個元素組合而成：</p>
<ul>
<li>HTTP 協議版本號</li>
<li>status code，告知對應請求的成功或失敗，以及原因</li>
<li>status message，描述訊息，可以由伺服器端指定</li>
<li>HTTP headers(與請求相似)</li>
<li>回應主體</li>
</ul>
<p>Content-type 重要的原因為，他指明了資源是以何種模式傳送，即使今日我發明了某種特殊的格式 <code>my-packed</code></p>
<p>只要伺服器端擷取 content-type 表頭，就可以知道應該以什麼樣的方式來存取資源</p>
<p>比方說實現一個伺服器，並把回傳表頭設定為 <code>text/plain</code>，而不是 <code>text/hmtl</code></p>
<p>這將會使得瀏覽器不把回傳內容當成 HTML 處理，因此會顯示：</p>
<p><img src="sections/related-work/./images/text-plain.png" alt="text-plain" /></p>
<p>而非平常看到的網頁形式</p>
<p>要注意的是，<strong>在瀏覽器上看到的一切，都是瀏覽器處理的</strong></p>
<p>比方說HTML文字，瀏覽器會繪製成精美的畫面；</p>
<p>使用 VSCode 打開，舊只是一連串的文字；</p>
<p>請注意<strong>某些行為，是由瀏覽器幫你完成的</strong></p>
<h2 id="https"><a class="header" href="#https">HTTPS</a></h2>
<p>在這裡，要特別提及的事情是 <code>HTTPS</code> 為什麼要特別提呢？</p>
<p>原因是因為，HTTPS的站點與HTTP的站點<strong>瀏覽器的行為會不一樣</strong></p>
<p>這是因為，HTTPS的站點瀏覽器會啟用 <code>Secure Contexts</code></p>
<p>而一般的HTTP的站點，會被限制某些 Web API，比方說 <code>麥克風</code>或是PWA的功能</p>
<p>以 Google Meeting 的功能來說，像是直播畫面、語音通話，在HTTP站點是<strong>不可能的</strong></p>
<p>Web API 中，有某些特別的 APIs，包含：</p>
<ul>
<li>需要用戶端設備的訪問權限</li>
<li>針對特殊數據的訪問，如用戶憑證</li>
</ul>
<p>就不允許在 <code>HTTP</code> 站點中使用</p>
<p>在 MDN 的 API 說明中，也會特別註記 <img src="sections/related-work/./images/secure-context.png" alt="secure-context" /></p>
<p>更多資訊參考 <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts">Secure Contexts</a></p>
<p>而有時候，會感覺 HTTPS 的站點<strong>好像比較快</strong></p>
<p>這也不是錯覺，因為 HTTPS 部分可能會啟用 HTTP/2 或是 SPDY 協議，因此不會限制併發數量</p>
<p>HTTP站點會限制同網域的最大併發數量，請見<a href="https://www.linkedin.com/pulse/why-does-your-browser-limit-number-concurrent-ishwar-rimal/">這裡</a></p>
<p>不過當使用 localhost 時，則不受到此限制，因為是透過 loopback 位址(127.0.0.0/8 or ::1/128)進行處理</p>
<h2 id="章節回顧-1"><a class="header" href="#章節回顧-1">章節回顧</a></h2>
<p>本章節把 HTTP 比較容易遺漏的部分看過一次，並指出HTTPS站點的行為與HTTP站點是不同的</p>
<ul>
<li>HTTP 的用戶端組成</li>
<li>Content-type 的重要性</li>
<li>瀏覽器的 Secure Contexts</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="網頁的基礎安全"><a class="header" href="#網頁的基礎安全">網頁的基礎安全</a></h1>
<p>在 WEB 中，也會有許多常見的攻擊手法，這些攻擊手法會被在OWASP的網站都會有紀錄</p>
<p><a href="https://owasp.org/Top10/A03_2021-Injection/">OWASP</a>：Open Web Application Security Project</p>
<p><img src="https://miro.medium.com/max/700/1*tTrkPKKqcC60WTUH191Xrw.png" alt="A" /></p>
<p><img src="https://miro.medium.com/max/700/1*Ru31cy3vVJhMSPWqct2CsQ.png" alt="B" /></p>
<p>雖然大部分都是後端處理時的漏洞，但是這裡簡單說明一下幾種常見的手法：</p>
<h2 id="inject"><a class="header" href="#inject">Inject</a></h2>
<blockquote>
<p>透過特殊的資料，導致語意的變化，就是Injection。XSS也合併到該類別之下</p>
</blockquote>
<p>其中最有名的例子就是 SQL Injection，</p>
<p>比方說伺服器的登入系統，實作如下：</p>
<pre><code class="language-js">function login(username, password) {
  const cmd = `SELECT COUNT(*) FROM db.user WHERE user = ${username} AND password = ${password}`;
  const result = await database.exec(cmd);
  return result &gt;= 1;
}
</code></pre>
<p>這裡用 <code>COUNT(*)</code> 來搜尋的結果，如果包含的資料多等於一筆，代表該用戶存在</p>
<p>那假設提交了一個特殊的帳號名稱，如：</p>
<pre><code class="language-conf">username=&quot;true;\nDELETE FROM user; #&quot;
password=&quot;password&quot;
</code></pre>
<p>那的SQL 指令會變成：</p>
<pre><code class="language-sql">SELECT COUNT(*) FROM db.user WHERE user = true;
DELETE FROM user; #AND password = 'password'
</code></pre>
<p>這將會導致資料庫的內容被刪除</p>
<p>而 XSS 的意思是 Cross-Site Scripting，比方說有個元件如下：</p>
<pre><code class="language-html">&lt;input id=&quot;textField&quot;&gt;
&lt;div id=&quot;output&quot;&gt;&lt;/div&gt;

&lt;script&gt;
const output = document.querySelector(&quot;#output&quot;);
const textField = document.querySelector(&quot;#textField&quot;);

textField.addEventListener(&quot;input&quot;, e =&gt; {
  output.innerHTML = e.target.value;
})
&lt;/script&gt;
</code></pre>
<p>倘若輸入 <code>&lt;a href=&quot;https://www.google.com/&quot;&gt;Click Me</code></p>
<p><img src="sections/related-work/./images/XSS.png" alt="XSS" /></p>
<h2 id="csrf"><a class="header" href="#csrf">CSRF</a></h2>
<p>CSRF 則是 Cross-site request forgery</p>
<p>比方說某個API可以轉帳：</p>
<pre><code class="language-text">https://bank.example.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName
</code></pre>
<p>那能在網頁上加入：</p>
<pre><code class="language-html">&lt;img src=&quot;https://bank.example.com/withdraw?account=Alice&amp;amount=1000&amp;for=Badman&quot; /&gt;
</code></pre>
<p>如果 Alice 剛剛結束銀行的操作，且登入資訊還保留在 Cookie 中，那麼當 Alice 存取該網站時，
Alice 就會轉帳給 Badman</p>
<p>常見的手法，可能會在輸入表單加入額外的</p>
<pre><code class="language-html">&lt;input type=&quot;hidden&quot; name=&quot;_token&quot; value=&quot;{Server提供的特殊Token}&quot;&gt;
</code></pre>
<p>不過這些漏洞算是常見的小兒科，接下來專注在程式碼上的處理，並說明一下瀏覽器安全策略</p>
<p>根據筆者開發的經驗，一定要避免：</p>
<ul>
<li>使用 <code>eval</code> 函式(<strong>大忌</strong>)</li>
<li>盡量不要直接操作 <code>innerHTML</code> 屬性</li>
</ul>
<h2 id="csp-content-security-policy"><a class="header" href="#csp-content-security-policy">CSP (Content-Security-Policy)</a></h2>
<p>Content-Security-Policy 是瀏覽器提供的安全層，用於檢測與削弱特定類型的攻擊</p>
<p>比方說 XSS 和 Injection，因為這兩種是很主要的攻擊手段</p>
<p>通常由伺服器端回傳 <code>Content-Security-Policy</code> 表頭，或是透過以下方式設定：</p>
<pre><code class="language-html">&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;&lt;policy&gt;&quot;&gt;
</code></pre>
<p>CSP 的主要目標是減少和報告 XSS 攻擊，XSS 攻擊利用了瀏覽器對於從服務器所獲取的內容的信任</p>
<p>惡意腳本在受害者的瀏覽器中得以運行，因為瀏覽器信任其內容來源，即使有的時候這些腳本並非來自於它本該來的地方</p>
<p>CSP 通過指定瀏覽器認可的有效來源——使服務器管理者有能力減少或消除 XSS 攻擊所依賴的載體</p>
<p>一個 CSP 兼容的瀏覽器將會僅執行從白名單域獲取到的腳本文件，忽略所有的其他腳本 (包括內聯腳本和 HTML 的事件處理屬性)</p>
<p>作為一種終極防護形式，始終不允許執行JavaScript的站點可以選擇全面禁止JavaScript執行</p>
<p>而 Policy 可以指定的範圍很廣，如圖片來源、字體來源、腳本來源 ... 等</p>
<p>幾乎只要是瀏覽器可以載入的資源，都可以設定，常用的作法如：</p>
<pre><code class="language-sh"># 僅允許同源站點(不包含子網域)
Content-Security-Policy: default-src 'self' 

# 僅允許同源站點(不包含子網域) 與 trusted.com 的子網域
Content-Security-Policy: default-src 'self' *.trusted.com

# 允許任何來源的圖片，但是影音來源與腳本來源受到限制
Content-Security-Policy: default-src 'self'; img-src *;
media-src media1.com media2.com;
script-src userscripts.example.com

# 只允許 HTTPS 協定以及信任 onlinebanking.jumbobank.com 來源的資料
Content-Security-Policy: default-src https://onlinebanking.jumbobank.com
</code></pre>
<p>更多內容請參考 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP">MDN: CSP</a></p>
<h2 id="cors-cross-origin-resource-sharing"><a class="header" href="#cors-cross-origin-resource-sharing">CORS (Cross-Origin Resource Sharing)</a></h2>
<p>當使用者代理請求一個不是目前文件來源——例如來自於不同網域（domain）、通訊協定（protocol）或通訊埠（port）的資源時，會建立一個跨來源 HTTP 請求（cross-origin HTTP request）</p>
<p>基於安全性考量，程式碼所發出的跨來源 HTTP 請求會受到限制</p>
<p>例如，XMLHttpRequest 及 Fetch 都遵守同源政策（same-origin policy）</p>
<p>這代表網路應用程式所使用的 API 除非使用 CORS 標頭，否則只能請求與應用程式相同網域的 HTTP 資源</p>
<p><img
  style="background: white; padding: 5px"
  src="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS/cors_principle.png"
/></p>
<p>當從站點A發出請求到站點B時，若站點B的回應不包含 CORS 表單，那麼站點A的請求便會擋下該回應</p>
<p>比方說有個請求與回應的內容如下：</p>
<pre><code class="language-text">GET /resources/access-control-with-credentials/ HTTP/1.1
Host: bar.other
User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Connection: keep-alive
Referer: http://foo.example/examples/credential.html
Origin: http://foo.example
Cookie: pageAccess=2


HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:34:52 GMT
Server: Apache/2.0.61 (Unix) PHP/4.4.7 mod_ssl/2.0.61 OpenSSL/0.9.7e mod_fastcgi/2.4.2 DAV/2 SVN/1.4.2
X-Powered-By: PHP/5.2.6
Access-Control-Allow-Origin: http://foo.example ❗
Access-Control-Allow-Credentials: true
Cache-Control: no-cache
Pragma: no-cache
Set-Cookie: pageAccess=3; expires=Wed, 31-Dec-2008 01:34:53 GMT
Vary: Accept-Encoding, Origin
Content-Encoding: gzip
Content-Length: 106
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain

[payload]
</code></pre>
<p>更多的內容請參考 <a href="https://developer.mozilla.org/zh-TW/docs/Web/HTTP/CORS#http_%E5%9B%9E%E6%87%89%E6%A8%99%E9%A0%AD">MDN: CORS</a></p>
<h2 id="章節回顧-2"><a class="header" href="#章節回顧-2">章節回顧</a></h2>
<p>本章節解釋了常見的網路攻擊手法，以及 OWASP 組織</p>
<p>並提出一些設計上應該避免的作法，最後帶出 CSP 與 CORS 的概念</p>
<ul>
<li>常見的攻擊手法</li>
<li>CSP 與 CORS 機制</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="客戶端與伺服端渲染"><a class="header" href="#客戶端與伺服端渲染">客戶端與伺服端渲染</a></h1>
<p>在進入 React 的開發之前，最後提一下客戶端渲染(CSR)與伺服端渲染(SSR)</p>
<h2 id="伺服端渲染-server-side-render"><a class="header" href="#伺服端渲染-server-side-render">伺服端渲染 (Server-Side Render)</a></h2>
<p>SSR，很常使用在如 PHP、Ruby 編寫的伺服器語言，以PHP來說</p>
<p>很常看到會有以下的寫法：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;?php
    $DB_HOST = 'localhost'; // 主機
    $DB_USER = 'root';  // 登入 MySQL server 的帳號
    $DB_PASS = 'password'; // 密碼
    $DB_NAME = 'mydb'; // 要登入的資料庫名稱

    $connection = mysqli_connet($DB_HOST, $DB_USER, $DB_PASS, $DB_NAME, $DB_NAME);

    if ($connection) {
      $query = 'SELECT * FROM User';
      $result = mysqli_query($connection, $query);
      $data = mysqli_fetch_array($result, MYSQLI_ASSOC);

    foreach ($row as $value) {
      echo _END
        &lt;div&gt; 用戶名稱： $row[&quot;username&quot;] &lt;/div&gt;
        &lt;div&gt; 用戶餘額： $row[&quot;balance&quot;] &lt;/div&gt;
      _END;
    }
  ?&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>注意到 <code>&lt;?php ?&gt;</code> 環繞的部分，因為 PHP 解釋器是通過該標籤來判斷，是不是要要進行翻譯的</p>
<p>由伺服器端把資訊給整理好，輸出成一份HTML文件，最後整份移交給客戶端，這種作法稱為&quot;伺服端渲染&quot;</p>
<h2 id="客戶端渲染-client-side-render"><a class="header" href="#客戶端渲染-client-side-render">客戶端渲染 (Client-Side Render)</a></h2>
<p>CSR 的做法就比較簡單，在前幾個章節，有提到 AJAX 和 REST API，</p>
<p>客戶端渲染的作法，就是由客戶端取的資料後，使用 JavaScript 進行繪製</p>
<h2 id="簡單比較"><a class="header" href="#簡單比較">簡單比較</a></h2>
<p>首先來看兩者的時序圖</p>
<h3 id="伺服器端渲染"><a class="header" href="#伺服器端渲染">伺服器端渲染</a></h3>
<p><img src="sections/related-work/images/SSR.png" alt="SSR" /></p>
<h3 id="客戶端渲染"><a class="header" href="#客戶端渲染">客戶端渲染</a></h3>
<p><img src="sections/related-work/images/CSR.png" alt="CSR" /></p>
<p>主要的差異在於，一張網頁上的所有資料，伺服器端渲染會在伺服器都處理好相關資訊，然後回傳一份文件給客戶端</p>
<p>而客戶端渲染則是由客戶端取得資料後，在使用JavaScript繪製出畫面</p>
<p>而現今的作法，都稱為<em>前後端分離</em>，前端使用如Vue、React、Angular 框架；</p>
<p>後端實作REST API，優點是關注點很好分離，且前後端各自維護也比較方便；</p>
<p>且可以把計算效能分散給終端的用戶，傳輸的資料量也比較小</p>
<p>缺點則是對於客戶端的效能比較要求，且不好做SEO</p>
<p>不過還是可以使用 Hybird 架構，比方說 &quot;首個頁面&quot; 使用伺服器端渲染，其後的畫面在使用客戶端渲染即可</p>
<h2 id="章節回顧-3"><a class="header" href="#章節回顧-3">章節回顧</a></h2>
<p>該章節僅釐清了 CSR 與 SSR 的概念，並且知道彼此的優缺點是什麼即可</p>
<ul>
<li>伺服端渲染</li>
<li>客戶端渲染</li>
<li>兩者差異</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javascript-core-概觀"><a class="header" href="#javascript-core-概觀">JavaScript Core 概觀</a></h1>
<p>在討論 JavaScript 的語法之前，首先快速的理解一下這個程式語言他能做到什麼事情，以及他在現今擔任的角色</p>
<blockquote>
<p>JavaScript 是一種腳本，也能稱它為程式語言，可以讓你在網頁中實現出複雜的功能</p>
<p>當網頁不只呈現靜態的內容，另外提供了像是：內容即時更新、地圖交動、繪製 2D/3D 圖形，影片播放控制……等，你就可以大膽地認為 JavaScript 已經參與其中</p>
</blockquote>
<p>以上是 MDN 對 JavaScript 的介紹。大家通常的印象，JavaScript 就是用在與網頁互動的應用上，和 HTML、CSS 三者構築成網頁的基石</p>
<p>本章節不著重在網頁(或者說，前端)應用的開發，而是專注在 JavaScript 上，得益於 Google V8 引擎的優異性能，早在數年前 JavaScript 便可獨立於瀏覽器運作；更進階一些的情境，也適用於嵌入式系統</p>
<p>換而言之，JavaScript 可以在不同的環境下運行，這個部份最後再來回顧，但是這裡要介紹的是 &quot;JavaScript Core&quot;，也就是與執行環境無關的部分</p>
<h2 id="runtime-environment"><a class="header" href="#runtime-environment">Runtime environment</a></h2>
<p>本章節所有的範例，可以透過 <a href="https://nodejs.org/en/">Node.js</a>或是 Browser DevTools 運作，Node.js 的架構在章節中間會提及；簡單的介紹，Node.js 是一個執行環境，採用Google V8 引擎，套用非阻塞與事件驅動的模型</p>
<p><img src="sections/js-core/./images/nodejs.png" alt="Nodejs" /></p>
<p>除了 Node.js，在主流的瀏覽器，按下 F12 或是 <code>Ctrl + Shift + I</code> 的組合鍵，也可以呼叫出 DevTools， 同樣也包含了 JavaScript 的執行環境</p>
<p><img src="sections/js-core/./images/DevTools.png" alt="DevTools" /></p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<p>本節內容主要依照</p>
<p>O'REILLY <a href="https://www.oreilly.com/library/view/javascript-cookbook-3rd/9781492055747/">JavaScript Cookbook</a></p>
<p>O'REILLY <a href="https://www.oreilly.com/library/view/javascript-the-definitive/9781491952016/">JavaScript: The Definitive Guide</a></p>
<p>以及 MDN 中的 <a href="https://developer.mozilla.org/zh-TW/docs/Learn/Getting_started_with_the_web/JavaScript_basics">JavaScript Basic</a></p>
<p>做為參考依據，萃取並簡化內容，盡可能快速讓初學者理解 JavaScript 的核心概念，章節末則整理常用的函式</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="語法速覽"><a class="header" href="#語法速覽">語法速覽</a></h1>
<p>本小節快速說明 JavaScript 的語法，倘若是有程式語言基礎的學員，可以快速瀏覽過即可</p>
<h2 id="變數宣告"><a class="header" href="#變數宣告">變數宣告</a></h2>
<pre><code class="language-js">var i = &quot;str&quot;; // 宣告一個變數

let j = 0;     // 宣告一個變數, After ES6

const k = 100; // 宣告一個常數, After ES6

/*
 * 多行註解
 */

// 單行註解
</code></pre>
<p>在早期 (ES5以前)，都是使用 <code>var</code> 關鍵字來宣告變數， ES6+ 則可以使用 <code>let</code> 或 <code>const</code> 宣告變數，不過 <code>var</code> 以及 <code>let</code> 的行為並不相同，最好都使用 <code>let</code>來宣告，這個問題保留到最後說明</p>
<h2 id="型別字面值"><a class="header" href="#型別字面值">型別字面值</a></h2>
<p>字面值的意思是，直接提供給 JavaScript 變數的值，且不使用<strong>建構式</strong>初始化，
舉例來說，陣列可以使用以下兩種方式宣告：</p>
<pre><code class="language-js">let users = ['Alex', 'Bob', 'Claire'];

let users = new Array('Alex', 'Bob', 'Claire');
</code></pre>
<p>在多數的情況下，最好使用字面值<code>(literals)</code> 來初始化內建型別</p>
<ul>
<li>Boolean: <code>true</code>, <code>false</code></li>
<li>Numerical：
<ul>
<li>(十進制) decimal： <code>0</code>, <code>100</code>, <code>-123</code></li>
<li>(八進制) octal： <code>015</code>, <code>021</code>, <code>-0o73</code></li>
<li>(十六進制) hex： <code>0x15</code>, <code>0x153</code>, <code>-0xf1A7</code>(a~f 不區分大小寫)</li>
<li>(二進制) binary： <code>0b11</code>, <code>0b0011</code>, <code>-0b11</code></li>
</ul>
</li>
<li>Floating：<code>.123</code>, <code>-.01</code>, <code>0.123</code>, <code>-0.1234</code>, <code>1e-34</code>, <code>1E+12</code></li>
<li>String：<code>'str, asd \n\r'</code>, <code>&quot;123 45 a1bd&quot;</code>, `template string`</li>
<li>RegExp： <code>/[a-z]*/</code></li>
<li>Array： <code>[0,1,2,3,4,5]</code></li>
<li>Object： <code>{ a: 30, b: &quot;str&quot;, c: true }</code></li>
</ul>
<p>比較特殊的部分是Template String，他是由兩個 <strong>`</strong> 符號構成的字串，可以在其中使用<code>${ expr }</code>嵌入表達式：</p>
<pre><code class="language-js">const name = &quot;Alex&quot;;
const age = 18;

const info = `${name} is ${age} year-old Man`
// 輸出 &quot;Alex is 18 year-old Man&quot;
</code></pre>
<h2 id="分支結構"><a class="header" href="#分支結構">分支結構</a></h2>
<pre><code class="language-js">// if-else
if ( condition ) {

} else {

}

// switch-case
switch( case ) {
  case 0: /* do something */ break;
  case 1: /* do something */ break;
  case 2: /* do something */ break;
  default break;
}
</code></pre>
<h2 id="迴圈結構"><a class="header" href="#迴圈結構">迴圈結構</a></h2>
<pre><code class="language-js">
while( i &lt; 100 ) {
  /* do something */

  if ( j == 50 ) continue;

  if ( k == 60 ) break;

  ++i;
}

for(let i = 0 ; i &lt; 100 ; ++i) {
  /* dosomething */
}

let obj = {
  a: 1,
  b: 2,
  c: 3,
  d: 4,
  key: 5,
  index: 6,
}

/* for ... in */
for(let key in obj) {}
for(const key in obj) {
  console.log(key)
  /* 依序印出 a b c d key index */
}

/* for ... of */
for(let value of obj) {}
for(const value of obj) {
  console.log(value);
  /* 依序印出 1 2 3 4 5 6 */
}
</code></pre>
<h2 id="定義類別"><a class="header" href="#定義類別">定義類別</a></h2>
<pre><code class="language-js">
class Rect {
  constructor(x1, y1, x2, y2) {
    /* 成員在建構式中宣告 */
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y2;
  }

  /* 宣告方法 */
  getArea() {
    return Math.abs((this.x2 - this.x1) * (this.y2 - this.y1));
  }
}

class Rect {
  constructor(x1, y1, x2, y2) {
    /* 成員在建構式中宣告 */
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y2;
  }

  /* 宣告方法 */
  getArea() {
    return Math.abs((this.x2 - this.x1) * (this.y2 - this.y1));
  }
}

class Square extends Rect {
  constructor(x1, y1, x2, y2) {
    super(x1, y1, x2, y2); // 呼叫父類別的建構式
  }
}

</code></pre>
<h2 id="錯誤處理"><a class="header" href="#錯誤處理">錯誤處理</a></h2>
<pre><code class="language-js">
try {
  throw new Error(&quot;Error&quot;);
} catch (error) {
  console.error(error);
}

/* catch 的 error 可以省略 */
try {
  throw new Error(&quot;Error&quot;);
} catch {
  console.error(&quot;something wrong&quot;);
}
</code></pre>
<p>以上就是 JavaScript 的常用語法，大部分都是 C-style 的樣子</p>
<h2 id="let-與-var"><a class="header" href="#let-與-var">let 與 var</a></h2>
<p>在 JavaScript 的宣告中，有一個特殊規則 &quot;提升&quot;(hoist)</p>
<blockquote>
<p>變數和函數的宣告會在編譯階段就被放入記憶體，但實際位置和程式碼中完全一樣
但是實際行為，就像是把宣告移動到頂層區域</p>
</blockquote>
<p>舉個例子來說：</p>
<pre><code class="language-js">function sayHello(name) {
  console.log(`${name} say: Hello!`);
}

sayHello(&quot;Alex&quot;);
</code></pre>
<p>以及</p>
<pre><code class="language-js">sayHello(&quot;Alex&quot;);

function sayHello(name) {
  console.log(`${name} say: Hello!`);
}
</code></pre>
<p>兩個例子，程式都可以順利運作；對於 C 語言的開發人員，可能不會覺得很特殊</p>
<p>畢竟本來就可以先宣告函式原型，在宣告實作</p>
<p>但是以下的例子，就顯得更特殊一點：</p>
<pre><code class="language-js">num = 7;
num = num2 + 1;
var num;
console.log(num);
</code></pre>
<p><img src="sections/js-core/./images/hoist1.png" alt="Hoist1" /></p>
<p>這個例子中，&quot;看起來&quot;好像跟預期的結果一樣，Runtime的時候告訴，並沒有宣告 <code>num2</code> 這個變數，但是修改一樣範例程式碼：</p>
<pre><code class="language-js">num = 7;
num = num2 + 1;
var num, num2; //多宣告 num2
console.log(num);
</code></pre>
<p><img src="sections/js-core/./images/hoist2.png" alt="Hoist2" /></p>
<p>令人驚訝的事情出現了，此時並沒有擲出 <code>ReferenceError</code>，程式碼的行為就如同：</p>
<pre><code class="language-js">var num, num2;
num = 7;
num = num2 + 1;
console.log(num);
</code></pre>
<p>因為就像是把宣告給&quot;提升&quot;到區域的最前面，所以該行為才被如此稱呼</p>
<p>對於使用 <code>var</code> 來宣告的變數，所有的宣告都被提至函數的最前面，請注意，<strong>僅有宣告</strong>，初始化的行為還是在原本的位置：</p>
<pre><code class="language-js">var x = 1;
console.log(x , y) // 1 undefined
var y = 2;
</code></pre>
<p>換句話說，該語法被解釋成：</p>
<pre><code class="language-js">var x;
var y;

x = 1;
console.log(x, y);
y = 2;
</code></pre>
<p>正如 MDN 宣稱的：<code>變數和函數的宣告會在編譯階段就被放入記憶體，但實際位置和程式碼中完全一樣。</code></p>
<p>這個行為算是該語言的歷史包袱，而在ES6之後，則出現了 <code>let</code> 與 <code>const</code> 關鍵字</p>
<h3 id="有何不同"><a class="header" href="#有何不同">有何不同</a></h3>
<p>最大的差異在於，<code>var</code> 的宣告基於 <code>函數(function)</code>，<code>let</code> 與 <code>const</code> 的宣告基於 <code>區塊(block)</code></p>
<p>舉出兩個例子：</p>
<pre><code class="language-js">function foo() {
  {
    /* scope 1 */
    var a = 10;
  }

  {
    /* scope 2 */
    var b = a + 10;
  }

  console.log( b );
}
foo() // output: 20
</code></pre>
<p>vs</p>
<pre><code class="language-js">function foo() {
  {
    /* scope 1 */
    let a = 10;
  }

  {
    /* scope 2 */
    let b = a + 10; // ReferenceError：a is not defined
  }

  console.log( b );
}
foo() // ReferenceError：a
</code></pre>
<p>兩個行為非常明顯，例子二無須多做解釋，其行為就好像寫程式的邏輯一般；而例子一，因為<code>var 基於函數的範圍</code>，因此可以理解成：</p>
<pre><code class="language-js">function foo() {
  var a;
  var b;
  {
    /* scope 1 */
    a = 10;
  }

  {
    /* scope 2 */
    b = a + 10;
  }

  console.log( b );
}
foo() // output: 20
</code></pre>
<p>因此只要在函數底下的任何區塊，使用 <code>var</code> 宣告，該變數在整個函數內都可以看見，一個簡單的處理方式是使用 IIFE(Immediately Invoked Function Expression)</p>
<pre><code class="language-js">function foo() {
  (function(){
    /* scope 1 */
    var a = 10;
  })();

  (function(){
    /* scope 2 */
    var b = a + 10; // ReferenceError：a is not defined
  })();

  console.log( b );
}
foo() // ReferenceError：a
</code></pre>
<p>透過包裹一層立即調用的函數，把變數給隔離起來</p>
<p>既然問題可以解決，那麼為什麼還需要<code>let</code> 跟 <code>const</code> 呢？</p>
<p>就是為了讓 JavaScript 的行為，更符合現代語言，且 <code>let</code> 還導入了<strong>暫時性死區(TDZ)</strong> 的概念，防止一個變數在使用前，被其他函數或變數<strong>引用</strong></p>
<pre><code class="language-js">
i = j + 10; // 可以運行
var i ,j;

x = y + 10; // ReferenceError
let x, y;
</code></pre>
<p>此外，<code>var</code> 宣告很容易沒有注意到，就錯誤的使用，例如在HTML的 <code>&lt;script&gt;&lt;/script&gt;</code> 撰寫如下的程式碼：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  
&lt;/body&gt;
&lt;script&gt;
/* some javascript code */
for(var i = 0; i &lt; n; ++i) { // &lt;-- for 是一個 block, 不是 function, 隱含的宣告了全域變數 i
  /* do something */
}
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p>如上圖所示，或者是在 <code>function</code> 宣告時，底下只要不小心使用到 <code>var</code> 宣告，該變數馬上就會變成該函數內可見的變數，另一個原因是，在瀏覽器的行為中，Global區塊使用<code>var</code> 宣告的變數，會被掛載到 <code>window</code> 物件底下：</p>
<p><img src="sections/js-core/./images/browser-var.png" alt="browser-var" /></p>
<p>因此，在現代的 JavaScript 撰寫中，請盡可能避免 <code>var</code> 的使用</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="型別系統"><a class="header" href="#型別系統">型別系統</a></h1>
<p>在該章節中，深入一點JavaScript中的型別系統</p>
<p>在 JavaScript 中，可以分成基礎型別(或稱原始型別)與複合型別</p>
<p>基礎的 7 種型別分別為</p>
<ul>
<li>Null</li>
<li>Undefined</li>
<li>Boolean(true, false)</li>
<li>Number</li>
<li>Bigint</li>
<li>String</li>
<li>Symbol</li>
</ul>
<p>複合型別包含了</p>
<ul>
<li>Function</li>
<li>Object</li>
</ul>
<p>快速理解 JavaScript 中的型別系統</p>
<hr />
<p>對於 Boolean、Number、String 這幾個型別可以用很簡單的方式說明</p>
<p>Boolean 即為 <code>false</code>、<code>true</code> 兩個字面值</p>
<p>Number 則是相當於C++的double值<code>(-(2^53-1) ~ 2^53 - 1)</code>的數值。除了這個範圍的數值中，還包含了<code>Infinity</code>、<code>-Infinity</code>、<code>NaN</code> 三個數值。<code>Infinity</code>、<code>-Infinity</code> 相當於正負無限
<code>NaN</code> 則是代表 <code>Not a Number</code>，通常會出現在不合法的運算，例如</p>
<pre><code class="language-js">let result = &quot;string&quot; - 100; // NaN
let result2 = &quot;test&quot; * 100   // NaN
let value1 = 100 / 0         // Infinity
let value2 = Math.log(0)     // -Infinity
typeof result === &quot;number&quot;   // true
</code></pre>
<p>請注意，&quot;不合法的運算&quot;是指，使用非&quot;number&quot;型別的運算子進行運算，並非是指 <code>100 / 0</code> 這種運算錯誤
此外， <code>NaN</code> 意思雖然是 <code>Not a Number</code> ，但是型別是 <code>number</code> 若要正確檢測 <code>NaN</code> 的型別，請使用 <code>isNaN()</code> 函式</p>
<p>String 則是指使用 <code>''</code>、<code>&quot;&quot;</code>、以及<code>``</code>所包覆起來的文字，<code>'string'</code> 與 <code>&quot;string&quot;</code> 還有 `string` 三者是同義的，而第三種以(``)則是樣板字串(Template String)，可以嵌入變數</p>
<pre><code class="language-js">let name = &quot;username&quot;
let str = `Hello, ${name}`

console.log(str) // &quot;Hello, username&quot;

// 等價以下語法：
let str_ = 'Hello, ' + name;

// 允許巢狀嵌入
let condtion = false;
let val1 = &quot;a1234567&quot;;
let val2 = &quot;b24681357&quot;;
let output = `condtion output: ${condtion ? `val1=${val1}` : `val2=${val2}`}`;
console.log(output) // &quot;condtion output: val2=b24681357&quot;
</code></pre>
<p>Bigint 則是大數型別，在數字後加上<code>n</code>，轉型為大數型別。當數字超過一定的範圍，會用字串型別進行處理，而Bigint提供了很基礎的運算：</p>
<pre><code class="language-js">let val1 = 2 ** 2000 // value out of number range: &quot;Infinity&quot;
let val2 = 2n ** 2000n /*
114813069527425452423283320117768198402231770208869520047764273682576626139237031385
665948631650626991844596463898746277344711896086305533142593135616665318539129989145
312280000688779148240044871428926990063486244781615463646388363947317026040466353970
904996558162398808944629605623311649536164221970332681344168908984458505602379484807
914058900934776500429002716706625830522008132236281291761267883317206598995396418127
021779858404042159853183251540889433902091920554957783589672039160081957216630582755
380425583726015528348786419432054508915275783882625175435528800822842770817965453762
184851149029376 */
</code></pre>
<p>Symbol 是個稍微複雜的型別，通常用來建立一個獨特的 Key 值，並作為物件中的成員值
更具體的細節請參考 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol">Symbol</a></p>
<p>而關鍵字 <code>typeof</code> 則是列出運算式的型別，其回傳值必定是以下幾個字串：</p>
<ul>
<li>&quot;bigint&quot;</li>
<li>&quot;boolean&quot;</li>
<li>&quot;function&quot;</li>
<li>&quot;number&quot;</li>
<li>&quot;object&quot;</li>
<li>&quot;string&quot;</li>
<li>&quot;undefined&quot;</li>
</ul>
<p>其中要注意的是，<code>typeof null</code>的回傳結果是 <code>object</code>， <code>typeof NaN</code>的回傳結果是 <code>number</code></p>
<h2 id="複合型別"><a class="header" href="#複合型別">複合型別</a></h2>
<p><code>Object</code> 與 <code>Function</code> 是複合型別，嚴格來說，僅有 Object 型別才對</p>
<p>先從 Object 開始提起：
在 JavaScript 中， Object &quot;模擬&quot;成 C++ 的類別，但是又有點不太相同
在JavaScript中，物件的實現方法稱為 &quot;原型鏈&quot; 或是繼承鏈，這裡用 C++ 的 Virtual Function 來說明:</p>
<p><img src="sections/js-core/./images/virtual-table.png" alt="virtual-table" /></p>
<p>倘若 D1 與 D2 皆繼承了 Base Class，當調用 <code>D1.function1</code> 或是 <code>D2.function2</code>，會先嘗試尋找類別本身的定義，倘若本身無定義的話；會嘗試調用 Base 上的定義
這與 JavaScript 物件的行為十分類似，在JavaScript 存在著所謂原型鏈的定義。先看看早期的JavaScript</p>
<pre><code class="language-js">/* Define Class, JavaScript 5 */
function User(name, job) {
  if(!(this instanceof User)) {
    throw new Error(&quot;User should use `new` to create Object&quot;);
  }
  this.name = name;
  this.job = job;
}

User.prototype.intro = function(){
  console.log(&quot;My name is &quot; + this.name + &quot; , is a &quot; + this.job);
}

var user = new User('Alex', 'student');
user.intro(); // &quot;My name is Alex , is a student&quot;
user.intro = function(){
  console.log(&quot;[&quot; + this.name + &quot;, &quot; + this.job + &quot;]&quot;);
}
</code></pre>
<p>請注意 <code>prototype</code> 這個屬性，可以把該屬性當成 <code>Virtual Member Table</code>，當調用 <code>user.intro</code> 時，
會依序檢查 <code>user.intro</code> &gt; <code>user.prototype.intro</code> &gt; <code>Object.prototype</code>
對於所有 JavaScript 物件，都是繼承自 <code>Object.prototype</code></p>
<p>在以前沒有 <code>class</code> 關鍵字時，是使用 <code>function</code> 作為函式定義，所以需要使用 <code>this instanceof [FunctionName]</code> 來檢查是調用 <code>User()</code> 還是 <code>new User</code>
關於更多類別的說明，會在下個章節中說明</p>
<p><strong>Note!</strong> Virtual Table的說明僅是舉例，內部如何實作未必如此</p>
<h2 id="深拷貝與淺拷貝"><a class="header" href="#深拷貝與淺拷貝">深拷貝與淺拷貝</a></h2>
<p>對於物件的比較，須注意不能用一般的方式進行比較，這是因為物件的行為比較接近C++中的指標/參考</p>
<p>舉例來說：</p>
<pre><code class="language-js">
let arr0 = new Array() // 補充一下，可以使用 new 來建立陣列
let arr1 = [1,2,3,4];  // 若使用 [] 和 {} 來建構陣列或物件，這種作法稱為字面值(Literal Value)宣告
let arr2 = [1,2,3,4];
let arr3 = arr2
arr1 === arr2 // false
arr3 === arr2 // true
</code></pre>
<p>在該例子中，<code>arr1</code> 與 <code>arr2</code> 有著一樣的成員，比較結果卻是 <code>false</code>
反之，<code>arr2</code>和<code>arr3</code> 的比較結果是 <code>true</code>。起初會有些疑惑，但是用等效的C++程式碼說明：</p>
<pre><code class="language-cpp">int* arr1 = new int(4);
int* arr2 = new int(4);
int* arr3 = arr1;
arr1 === arr2 // false(因為 address 不同)
arr3 === arr2 // true(因為 address 相同)
</code></pre>
<p>這可以說明JavaScript中物件的作法，是比較接近指標，但是看起來卻像是參考，比方說</p>
<pre><code class="language-js">function append(arr, value) {
  arr.push(value);
}

let x = [];
append(x, 100);
console.log(x) // [100]
let y = x;
append(y, 200);
console.log(x) // [100, 200]
</code></pre>
<p>當第一次調用 append 時，會把 x 的位址傳入 append；因此外部的 x 被修改了</p>
<p>接下來把 y 指向 x，然後調用<code>append(y, 200)</code>，再次檢查 x 的值，會發現 x 值再次被修改了</p>
<p>對於第二次 <code>append</code>，可以看做 append 內部的 <code>arr 指向 y，y 又指向 x</code>，因此才會被修改</p>
<p>淺拷貝的意思是：<code>不同物件的成員，擁有相同的參考</code>，即為淺拷貝。舉例來說</p>
<pre><code class="language-js">let Parent = {
  arr: [0,1,2,3,4]
};

let ChildA = {
  arr: Parent.arr
};

let ChildB = {
  arr: Parent.arr
};
// ChildA.arr === ChildB.arr
</code></pre>
<p>在這種情況下，因為已經有指標的概念了，所以會注意到 <code>arr: Parent.arr</code> 把同一個物件指定給 ChildA 跟 ChildB 了</p>
<p>若你對 JavaScript 有點概念，可能知道 Object 可以使用 <code>Parent.arr</code> 或是 <code>Parent[&quot;arr&quot;]</code> 的方式使用成員，因此你有可能誤用</p>
<pre><code class="language-js">function clone(source, target) {
  for(const [key, value] of Object.entries(source) ) {
    target[key] = value;
  }
}

let ChildC = {};
let ChildD = {};
clone(Parent, ChildC);
clone(Parent, ChildD);
ChildC === ChildD // false
ChildC.arr === ChildD.arr // true
</code></pre>
<h2 id="深拷貝"><a class="header" href="#深拷貝">深拷貝</a></h2>
<p>深拷貝的定義相對單純，可以解釋為<code>不同物件的成員，都擁有不同的參考</code>
以上面的定義，若要複製 array，有幾種方法：</p>
<pre><code class="language-js">let arr = [0,1,2,3,4];

// sol1?
function clone(source) {
  let temp = [];
  for(const value of source)
    temp.push(value);
  return temp;
}
let arr1 = clone(arr);

// sol2?
let arr2 = [...arr];

// sol3?
let arr3 = arr.map(e =&gt; e);

//sol4:
let arr4 = JSON.parse(JSON.stringify(arr));

// arr1 ~ arr4 的值皆為 [0,1,2,3,4]，且都不等於 arr
</code></pre>
<p>但是請注意，倘若陣列中的值是物件，比方說<code>[{}, {}, {}, {}]</code>，那麼 arr1 ~ arr4 雖然互不相等</p>
<p>但是 <code>arr1[0]、arr2[0]、arr[0]</code> 都會等於 <code>arr[0]</code>，因為他們內部都是指向 arr[0]</p>
<p>而 arr4 則是<strong>完全複製</strong>，也就是說進行<code>arr4[0].x = 100</code> 這種修改，是不會影響到<code>arr[0]</code>的</p>
<p>因此，僅有 sol4 才算是深拷貝，因為他是先把物件進行 JSON 的序列化，在反序列化回來</p>
<p>這種作法無法複製function(JSON.stringify 不會轉譯function)，也不會複製<code>undefined</code></p>
<p>通常深拷貝的使用次數不多，且都有Library可以處理，因此只要有概念即可</p>
<h2 id="型別間的比較"><a class="header" href="#型別間的比較">型別間的比較</a></h2>
<p>在前面幾個章節，會發現交錯使用 <code>==</code> 和 <code>===</code>，有些人會說 <code>===</code> 指的是嚴格比較，該說法有點道理，但是實際上更單純</p>
<p>先從 JavaScript 的運算子說明，每個運算子都會定義兩邊的運算元型別，而JavaScript有個轉換的優先順序：</p>
<pre><code class="language-js">/* '+' 運算子可以用在 string + string 或是 number + number */
let a = 'str' + 'ing' //string
let b = 1 + 2 // 3
let c = '200' + 100 // string 的優先度高於 number，先把 100 轉為 '100'，然後相加字串
c // '200100'

/* '-' 運算子僅能用在 number + number */
let d = '1000' - 100 // - 僅接受兩個 number，嘗試把 '1000'轉為 1000，然後相減
d // 900
let e = '100a' - 100 // '100a' 無法轉換為 number，該計算結果為 NaN
</code></pre>
<p>那麼回到 <code>==</code> 和 <code>===</code>， <code>==</code> 的語意是<strong>比較時，允許型別轉換</strong>；<code>===</code> 的語意則是 <strong>比較時，不允許型別轉換</strong></p>
<p>大致上來說，轉換的順序可以看成 string &gt; number &gt; boolean，當運算元是不同型別的時候，會向上轉換一階：</p>
<pre><code class="language-js">console.log(true == 1) // true
console.log(true == 'true') // false

/* 分析一下 true == 'true' 這個例子 */
console.log(true == 1) // 代表 Number(true) 會轉成 1
console.log('1' == 1)  // 代表 String(1) 會轉成 '1'
console.log(true == '1') // true，左側進行 String(Number(true)) 得到 '1'
</code></pre>
<p>但凡事都存在例外，<strong>物件</strong>可以定義 toString 以及 toJSON，來決定被轉換成 <code>string</code> 和 <code>JSON</code> 的方法
Object 的轉換都會直接<strong>隱式</strong>調用 <code>obj.toString()</code> 方法</p>
<pre><code class="language-js">let obj = {};

obj == 10000 // false，因為 obj 會轉換成 '[object Object]'，此時變成 compare(string, number)
//於是 10000 會進行 String(10000) 得到 '10000'，而 '[object Object]' 不相等於 '10000'

let objA = {};
objA == '[object Object]' // true

// 手動定義 toString 方法
objA.toString = function(){
  return 10000
}

objA == 10000 // true
</code></pre>
<p>而 <code>===</code> 和 <code>!==</code> 就是告知JS引擎，比較時不允許隱式轉換型別</p>
<h2 id="深入理解"><a class="header" href="#深入理解">深入理解</a></h2>
<p><img src="sections/js-core/./images/wtfjs.png" alt="meme" /></p>
<p>由左至右，由上至下來說明這個梗圖：</p>
<h3 id="typeof-nan"><a class="header" href="#typeof-nan">typeof NaN</a></h3>
<p><code>typeof NaN</code> 前有說明，NaN 定義於 IEEE 754，表示無效操作(不等同於算數溢位)，但是沒有特別定義 NaN 是否為 number
在JS中，使用 isNaN 來檢測 <code>NaN</code> 值</p>
<h3 id="9999999999999999"><a class="header" href="#9999999999999999">9999999999999999</a></h3>
<p>9999999999999999 == 10000000000000000 是浮點數的誤差</p>
<h3 id="0501--0102"><a class="header" href="#0501--0102">0.5+0.1 , 0.1+0.2</a></h3>
<p>僅出現在 0.1 + 0.2 的時候，浮點數會出現誤差，
而 0.5 + 0.1 並不會，這也是 IEEE 754 的錯誤，高精度比較法可以用</p>
<pre><code class="language-js">function equal(a, b) {
  let value = Math.abs(a - b);
  return value &lt; 1e-15;
}

equal(0.1+0.2 , 0.3) // true
</code></pre>
<p>其中 <code>1e-15</code> 是可以自行定義的門檻值，核心作法為&quot;當計算結果小於一個誤差值，視為相同&quot;</p>
<h3 id="mathmax--mathmin"><a class="header" href="#mathmax--mathmin">Math.max , Math.min</a></h3>
<p><code>Math.max</code> 的簽章是 <code>Math.max(n1, n2, n3, ...)</code> 會回傳參數中的最大數值
他內部的實作類似：</p>
<pre><code class="language-js">Math.max = function(...args) {
  let currentValue = -Infinity;
  for(const value of args) {
    if(value &gt; currentValue)
      currentValue = value;
  }
  return currentValue;
}
</code></pre>
<p>照圖上的 <code>Math.max()</code>，沒有傳入參數的話，會導致 for-loop 不進行疊代，所以直接回傳<code>currentValue</code>，也就是 -Infinity
<code>Math.min</code>的狀況類似，只是 <code>if</code> 判斷改成 <code>value &lt; currentValue</code></p>
<h3 id="--------"><a class="header" href="#--------">[ ]+[ ], [ ]+{ }, { }+[ ]</a></h3>
<p><code>[] + []</code>，在陣列中，轉換為 string 實際上是調用了 <code>join</code> 這個方法，因此</p>
<pre><code class="language-js">let arr = [1,2,3,4,5,6,7];
arr == arr.join(); // true
arr.join() // '1,2,3,4,5,6,7'

arr == arr.join(' '); // false
arr.join(' ') //1 2 3 4 5 6 7
</code></pre>
<p><code>join(token)</code> 的作法是先把陣列的所有元素轉換為 <code>string</code> 型別，再透過 token 連接起來</p>
<p><code>[] + {}</code> 則是如同前面說的，會先把 <code>[]</code> 轉換成 <code>''</code>，然後把 <code>{}</code> 轉換成 <code>'[object Object]'</code>再把 <code>'' + '[object Object]'</code> 字串合併得到 <code>'[object Object]'</code></p>
<p><code>{} + []</code> 為0比較特殊，因為 <code>{}</code> 不可進行估算，所以實際上會看成 <code>{} (+[])</code>，而<code>+[]</code> 會轉成 0，然後進行 <code>{} 0</code> 得出0
這看起來是這個奇怪的結果？首先要知道JS引擎首次估算是用直譯的，所以可能的過程是：</p>
<pre><code class="language-js">// {} 0 改寫成
{
  /* empty scope */
}
0
</code></pre>
<p>換句話說，<code>{} + []</code>前面的<code>{}</code> <strong>不是物件</strong>，而是當成scope的宣告；接下來後面接一個數值，因此得出 0</p>
<p>證據就是，<code>()</code>不允許定義scope，倘若改成 <code>({}) + []</code> 就會視作兩個值進行<code>+</code>運算，所以會轉換成 <code>'[object Object]' + ''</code>，<code>({}) + []</code> 就會等同 <code>[] + {}</code></p>
<h4 id="truetruetrue-true-true-true1-true-1"><a class="header" href="#truetruetrue-true-true-true1-true-1">true+true+true, true-true, true==1, true ===1</a></h4>
<p>先理解成</p>
<ol>
<li><code>true</code> 會轉為 Number 1</li>
<li><code>==</code> 會進行型別轉換；<code>===</code>不會轉換</li>
<li>boolean 會先嘗試轉換為 <code>number</code>，然後是 <code>string</code></li>
</ol>
<h4 id="length"><a class="header" href="#length">(!+[]+[]+![]).length</a></h4>
<p><code>(!+[]+[]+![]).length</code>
先拆解成</p>
<ol>
<li><code>!(+[])</code> - <code>+[]</code>會變成 <code>+''</code>，然後轉為 0，!0 會轉為 <code>true</code></li>
<li><code>[]</code> - 轉換成 <code>''</code></li>
<li><code>![]</code> - <code>[]</code> 轉換成 <code>true</code>，然後運算<code>!true</code> 得到 <code>false</code></li>
</ol>
<p>三個值相加得到 <code>'truefalse'</code>，該字串長度為 <code>9</code></p>
<h4 id="91-91-1"><a class="header" href="#91-91-1">9+&quot;1&quot;, 91-&quot;1&quot;</a></h4>
<p>請看上面章節<a href="sections/js-core/Types.html#%E5%9E%8B%E5%88%A5%E9%96%93%E7%9A%84%E6%AF%94%E8%BC%83">型別間的比較</a></p>
<h4 id="17"><a class="header" href="#17">17</a></h4>
<p><code>[] == 0</code> 因為 Number([]) 轉換成 0， 0 == 0 得到 <code>true</code></p>
<h2 id="章節回顧-4"><a class="header" href="#章節回顧-4">章節回顧</a></h2>
<p>該章節要描述的概念是 JavaScript 中的型別系統，倘若你是初學者，會不太理解為什麼他表現的狀況跟你想的不一樣</p>
<ul>
<li>理解 JavaScript 中的型別</li>
<li>理解Object、Function是使用類似 reference 的方式做傳遞</li>
<li>知道<strong>深拷貝與淺拷貝</strong>的意義(非常重要)</li>
<li>比較(==) 和 嚴格比較(===) 兩個運算子的意義</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="物件與類別"><a class="header" href="#物件與類別">物件與類別</a></h1>
<p>在上個章節中，提到了<code>原型鏈</code>的概念</p>
<p>這裡稍微深入一下：先以ES 2015的規格來舉例</p>
<pre><code class="language-js">function Rect(w,h) {
  if(!(this instanceof Rect))
    throw new Error('is constructor');
  this.w = w;
  this.h = h;
}

Rect.prototype.add = function (r) {
  if(!(r instanceof Rect))
    throw new TypeError('Only allow Rect-type');
  this.w += r.w;
  this.h += r.h;
}

Rect.prototype.print = function () {
  console.log(this.w + ', ' + this.h);
}

let r1 = new Rect(1,1);
let r2 = new Rect(2,2);
r1.add(r2);
r1.print(); // '3, 3'
</code></pre>
<p>這裡定義了一個<code>Rect</code>型別，並定義了 add 與 print 方法。當宣告了一個物件時，便可以同時定義他的<code>prototype</code></p>
<p>已知，當調用 function 的順序(<code>例如 Rect.add</code>)時，會依序查找<code>Rect.add</code> <code>Rect.prototype.add</code> <code>Object.prototype.add</code></p>
<p>這時候有個小問題：倘若直接回傳一個 Object 呢？比方說：</p>
<pre><code class="language-js">function Rect(w,h) {
  return {
    w: w,
    h: h,
    add: function(r) {
      this.w += r.w;
      this.h += r.h;
    },
    print: function() {
      console.log(this.w + ', '+ this.h);
    }
  }
}

let r1 = Rect(1,1);
let r2 = Rect(2,2);
r1.add(r2);
r1.print()
</code></pre>
<p>這個行為&quot;看起來&quot;會跟使用 <code>new Rect</code> 一樣，但是有個非常嚴重的問題，就是<code>r1.add !== r2.add</code></p>
<p>這個問題的嚴重性在於，假定定義了像是<code>MyArray</code> 這種類別，並且有個方法 <code>forEach</code>，當的網頁建立了 1000 個陣列</p>
<p><strong>forEach</strong> 也會被建立1000次，這對於記憶體的處理是非常不健康的</p>
<p>邏輯上，成員變數應該保持在自己的scope，而方法(例如 <code>MyArray.forEach</code>) 是一個獨立的 function，由所有的<code>MyArray</code>共用該 function</p>
<p>僅需要傳入自己的參考，MyArray便會假設 <code>this</code> 是自己傳進來的參考；</p>
<p>再次使用C++來舉例，C++的class實作其實隱含了<code>this</code>參數，比方說</p>
<pre><code class="language-cpp">class Point {
public:
  Point(int x, int y): x_(x), y_(y) {}

  void add(Point p) {
    this.x_ += p.x_;
    this.y_ += p.y_;
  }

private:
  int x_;
  int y_;
}
</code></pre>
<p>實際上 <code>add</code> 的簽章會包含一個隱含的參數<code>this</code></p>
<pre><code class="language-cpp">void Point::add(Point* this, Point p) {
  this.x_ += p.x_;
  this.y_ += p.y_;
}
</code></pre>
<p>可以使用以下的程式碼來檢視：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;functional&gt;

class Point {
public:
  Point(int x, int y): x_(x), y_(y) {}

  void add(Point&amp; p) {
    this-&gt;x_ += p.x_;
    this-&gt;y_ += p.y_;
  }

  int x_;
  int y_;
};

int main() {
  Point p1(1,1);
  Point p2(3,3);
  Point POINT(10,10);

  auto fn = std::bind(&amp;Point::add, &amp;POINT, std::placeholders::_1);
  fn(p1);
  std::cout &lt;&lt; POINT.x_ &lt;&lt; &quot;, &quot; &lt;&lt; POINT.y_ &lt;&lt; &quot;\n&quot;;
  //11, 11
  fn(p2);
  std::cout &lt;&lt; POINT.x_ &lt;&lt; &quot;, &quot; &lt;&lt; POINT.y_ &lt;&lt; &quot;\n&quot;;
  //14, 14
}
</code></pre>
<p>可以看到綁定了 <code>&amp;Point::add</code>，實際上是需要傳入兩個參數：<code>Point*</code> 與 <code>Point&amp;</code>
而把第一個參數綁定在 POINT上，因此 fn 傳入任何參數，都會修改到 POINT</p>
<h2 id="es6-底下的類別"><a class="header" href="#es6-底下的類別">ES6 底下的類別</a></h2>
<p>幸好在 ES6 (ECMA 2016)以後的標準，提供了 <code>class</code> 與 <code>extends</code> 關鍵字，上方的 <code>Rect</code> 可寫為</p>
<pre><code class="language-js">class Rect {
  constructor(w, h) {
    this.w = w;
    this.h = h;
  }

  add(r) {
    this.w += r.w;
    this.h += r.h;
  }

  print() {
    console.log(this.w + ', ' + this.h);
  }
}

let r1 = new Rect(1,1);
let r2 = new Rect(2,2);
r1.add(r2);
r1.print(); // '3, 3'
</code></pre>
<p>倘若多定義了 <code>Square</code> 正方形類別，只需要透過 <code>extends</code> 關鍵字即可</p>
<pre><code class="language-js">class Square extends Rect {
  constructor(w) {
    super(w, w);
  }

  getArea() {
    return this.w * this.h;
  }
}

let s1 = new Square(10);
s1.getArea(); // 100
</code></pre>
<p><code>super</code> 關鍵字會依照不同context，決定super的數值。在此處中，是調用 Parent Class 的建構式</p>
<p>在早期，需要手動處理 prototype 的指向來模擬繼承：</p>
<pre><code class="language-js">// Rect - 父類別
function Rect(w,h) {
  if(!(this instanceof Rect))
    throw new Error('is constructor');
  this.w = w;
  this.h = h;
}

// 父類別的方法
Rect.prototype.add = function (r) {
  if(!(r instanceof Rect))
    throw new TypeError('Only allow Rect-type');
  this.w += r.w;
  this.h += r.h;
}

Rect.prototype.print = function () {
  console.log(this.w + ', ' + this.h);
}


// Square - 子類別
function Square() {
  Rect.call(this); // call super constructor.
}

// 子類別擴展(extends)父類別
Square.prototype = Object.create(Rect.prototype);
Square.prototype.constructor = Square;

var rect = new Square();

console.log('Is rect an instance of Square?', rect instanceof Square);// true
console.log('Is rect an instance of Rect?', rect instanceof Rect);// true
rect.move(1, 1); // Outputs, 'Shape moved.'
</code></pre>
<p>在章節的最後，會放上包含所有成員檢查的實現方式</p>
<p>倘若加上了 <code>static</code> 關鍵字，其行為如同 C++的靜態方法:</p>
<pre><code class="language-js">class Square extends Rect {
  static internal = -1;

  constructor(w) {
    super(w, w);
  }

  getArea() {
    return this.w * this.h;
  }
}

let s1 = new Square(10);
s1.getArea(); // 100
Square.internal // -1

// ES 5 以前：
function Square(w) {
  if(!(this instanceof Square))
    throw new Error('');
}

Square.prototype.getArea = function(){ /* impl */ }
Square.internal = -1;
</code></pre>
<p>此外，類別可以使用 <code>new Square</code> 或是 <code>new Square()</code> 的方式初始化(假設建構式不需要參數)，他們的差異是運算子優先順序</p>
<p>因為 <code>.</code> 成員存取算運子的順序最高，所以使用</p>
<p><code>new Square.getArea</code> 會導致錯誤，因為 <code>Square</code>不存在 <code>getArea</code> 方法，但是使用</p>
<p><code>new Square().getArea</code> 則不會出錯，因為他實際上調用了 <code>(new Square).getArea</code></p>
<p>懶人包： <code>new Class().method() 等同於 (new Class).method()</code>;</p>
<h2 id="this"><a class="header" href="#this">this</a></h2>
<p><strong>Note!</strong> 僅說明嚴格模式(strict mode) 下的情況</p>
<p>嚴格模式通常會直接在腳本的第一行撰寫 <code>use &quot;strict&quot;;</code> 啟動，嚴格模式可以參考MDN的<a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Strict_mode">strict mode</a>說明，在開發JavaScript應用時，基本上是一定會加上的</p>
<p>this是一個特殊的值，無法於執行期間被覆蓋</p>
<p>對於一般的function，查找this的範圍會從 caller 往上查找：</p>
<pre><code class="language-js">let obj = {
  prop: 300,
  fn: function() {
    return this.prop;
  }
}

obj.fn() // 300;

// ==========

function outerFn() {
  return this.prop;
}
outerFn() // Error, this(=outerFn) 並沒有 prop 這個成員

obj.fn = outerFn;

obj.fn() // 300, 因為此時 outerFn 繫結於 obj 的成員位址
</code></pre>
<p>請注意，<code>this</code> 的查找僅受到直接引用的影響，舉例來說：</p>
<pre><code class="language-js">function fn() {
  return this.prop;
}

let obj = {
  prop: 100,
  foo: fn,
  sub: {
    prop: 200,
    foo: fn
  }
}

obj.foo();  // 100
obj.sub.foo();  // 200

// 假設修改obj.sub為
obj.sub = {
  // prop: 200,
  foo: fn
}
obj.sub.foo() // undefined, 因為最直接的引用是 obj.sub，該物件沒有prop成員

obj.sub.__proto__.prop = 300;
obj.sub.foo() // 300, 最直接的引用是 obj.sub，該物件沒有prop成員，但是原型鏈存在prop成員

</code></pre>
<h2 id="閉包與-arrow-function"><a class="header" href="#閉包與-arrow-function">閉包與 arrow function</a></h2>
<p>箭頭函數(arrow function)，也被叫作 &quot;lambda&quot; 表達式，其表示法如下</p>
<pre><code class="language-js">// ex.1
const sum = (a, b) =&gt; {
  return a + b;
};

// ex.2 當 `=&gt;` 後接的是 expression 時，可以當作回傳值
const sum = (a, b) =&gt; a + b // 行為同 ex.1

// ex.3
const sayHello = (name) =&gt; `Hello, ${name}`

// ex.4
const sayHello = name =&gt; `Hello, ${name}` // 只有一個參數時，可以省略()

// ex.5
const returnObj = ( user ) =&gt; ({
  name: user.first + ' ' + user.last,
  age: user.age,
})
// 倘若使用 user =&gt; {}，此時的 {} 會被視作 scope statement，使用 ({}) 可強制視為 expression
</code></pre>
<p><strong>this的本質</strong>
對於一般函數來說，this的建構順序如下：</p>
<ul>
<li>作為 new 建構子來說，是個新物件</li>
<li>對於嚴格模式下的直接調用，this 是undefined</li>
<li>作為物件的方法呼叫時，參考至物件上</li>
</ul>
<p>更準確來說，arrow function 沒有自己的 this</p>
<p><strong>function a() {}</strong> 以及 <strong>let a = () =&gt; {}</strong> 絕對是不同的東西</p>
<p>最主要的差異在於，arrow function 以及普通 function 所看見的 context 是不一樣的</p>
<p>這點可能會在使用 <code>React</code> 或是 <code>Vue</code> 開發的時候，看到官方強調，何時一定要使用 <code>function</code>，而不能用 <code>arrow function</code> 代替</p>
<pre><code class="language-js">function Person() {
  this.age = 1;

  setInterval(function growUp(){
    this.age++; // 錯誤，因為 setInterval 的調用不是由 Person 的instance 執行
    // 通常為 undefined, 非嚴格模式下為 window
  });
}

// solution
function Person() {
  this.age = 1;
  const self = this;
  setInterval(function growUp(){
    self.age++; // 正確運作，因為先用 self 把 this 的位址保存下來，並透過閉包傳遞
  });
}

// solution 2
function Person() {
  this.age = 1;
  setInterval(() =&gt; {
    this.age++ // 正確，因為arrow function的this是基於詞法域的
  })
}
</code></pre>
<h2 id="閉包與詞法域"><a class="header" href="#閉包與詞法域">閉包與詞法域</a></h2>
<p>通俗的解釋，語法域代表的是執行期間動態決定的行為，比方說普通函式的<code>this</code>、建構式的<code>super</code></p>
<p>而詞法域代表的是封閉範圍的前後文，如同變數的查找一樣，舉例來說：</p>
<pre><code class="language-js">{
  let a = 100;
  let b = 200;
  {
    let c = 300;
    function fn() {
      console.log(a, b, c);
    }
    fn() // 100, 200, 300
  }
  {
    function fn() {
      console.log(a, b, c);
    }
    fn() // 錯誤，c 不存於該 scope
  }
}
</code></pre>
<p>以各位的基礎，很清楚明白 <code>a, b</code> 在一個 scope, 而 <code>c</code> 在的scope可以看到外部(祖先block)</p>
<p>所以第一個 sub block 可以看到 a,b,c，但是第二個僅能看到 a,b</p>
<p>這就是詞法域(其行為依照原始碼的樣子)</p>
<p>而閉包則複雜一點，以上面的例子來說，可以觀察出幾個結果：</p>
<ul>
<li>scope 是允許巢狀</li>
<li>內部的 scope 可以存取外部的 scope</li>
<li>外部的 scope 不可以存取內部的 scope</li>
</ul>
<p>閉包的概念，就好像透過 <code>function</code>，把內部的變數帶出去外面：</p>
<pre><code class="language-js">function closure(initValue) {
  let sum = initValue;
  return function(num) {
    sum += num;
    return sum;
  }
}

const sigmaFn = closure(0);
sigmaFn(100); // 100
sigmaFn(100); // 200
sigmaFn(100); // 300
</code></pre>
<p>首先定義了 <code>closure</code>，僅允許傳入參數來初始化 sum</p>
<p>並回傳一個 <code>function</code>，可以傳入數字來遞增 sum</p>
<p>每一次呼叫 <code>sigma</code>，都會遞增 sum 的值，這看起來似乎沒有什麼特別，但是稍微修改一下：</p>
<pre><code class="language-js">function closure(initValue) {
  let sum = initValue;
  return {
    add: function(num) {
      sum += num;
      return sum;
    }
  }
}

const calc = closure(100);
calc.add(20);
calc.add(30);
</code></pre>
<p>把回傳值改為物件，並包含了sum值，這有兩個很特殊的作用：</p>
<ul>
<li>在回傳的物件中，不需要用到 <code>this</code></li>
<li>無法透過 calc 直接存取 sum，只能透過<code>add</code>來存取</li>
</ul>
<p>在早期沒有arrow function時，閉包可以很好的處理this的context，而第二點則至關重要：封閉了sum的直接修改，僅允許公開的方法存取</p>
<p>這個行為，就像是把 sum 定義為 <em>private</em> 成員，add 為 <em>public</em> 成員，透過閉包，可以模擬出物件導向的行為</p>
<p>現在閉包用法則是比較偏向第二點，因為this已經有arrow function跟 class 關鍵字協助處理了</p>
<p>通常會使用閉包來移轉內部資料的所有權到外部</p>
<p>另外一個層面是，閉包可以很好的處理早期 <code>var</code> 宣告的問題(請見 <a href="sections/js-core/./Syntax.html#let-%E8%88%87-var">語法速覽</a>)，而UMD模組載入模式，也會看到閉包的使用</p>
<h2 id="章節回顧-5"><a class="header" href="#章節回顧-5">章節回顧</a></h2>
<p>此章節模擬了 JavaScript 與 C++ 的類別系統，並猜測JS引擎中實現類別的作法</p>
<ul>
<li>理解原型鏈的概念</li>
<li>知道 ES6 是如何定義物件的</li>
<li>能大致區分<code>normal function</code>與<code>arrow function</code>的差異</li>
<li>對於閉包有基本的理解</li>
</ul>
<h2 id="附錄"><a class="header" href="#附錄">附錄</a></h2>
<p>包含型別檢查的繼承方式(ES5) 請參考 <a href="sections/js-core//appendix/es5-class.html">ES5 class</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javascript-架構"><a class="header" href="#javascript-架構">JavaScript 架構</a></h1>
<p>在這個章節，會先說明非同步程式的概念，假設有個程式這樣寫：</p>
<pre><code class="language-js">const arr = [];
arr.push(1);
arr.push(2);
arr.push(3);
arr.push(4);
console.log(arr) // [1,2,3,4]
</code></pre>
<p>在這個例子中，程式碼都是由上到下執行，因此很好預測執行結果
但如果程式碼改成以下模式：</p>
<pre><code class="language-js">
const arr = []
let fileA = download(urlA);
let fileB = download(urlB);
let fileC = download(urlC);

while( !(fileA.done &amp;&amp; fileB.done &amp;&amp; fileC.done) ) {
  if(fileA.done &amp;&amp; !fileA.lock) {
    arr.push(fileA.content);
    fileA.writeLock();
  }
  if(fileB.done &amp;&amp; !fileB.lock) {
    arr.push(fileB.content);
    fileB.writeLock();
  }
  if(fileC.done &amp;&amp; !fileC.lock) {
    arr.push(fileC.content);
    fileC.writeLock();
  }
}
</code></pre>
<p>假設有個想像的程式碼，會下載三個網站的內容，並有個迴圈檢測是否下載完成；如果有任何網站還未下載完成，就不會離開迴圈</p>
<p>迴圈會依序檢查A、B、C的內容，若下載完成後，把資料放入<code>arr</code>中，並且上鎖防止重複寫入</p>
<p>有個關鍵的問題是：<code>arr</code>中資料的順序為何 ？無從得知</p>
<p>或許可以改成： <code>arr[0] = fileA.content</code>這種做法來確定資料的順序，但是這不切實際</p>
<p>比方說需要先登入銀行、然後才能操作帳戶，操作順序有時序性；當步驟越來越繁瑣</p>
<p>無法確定API回傳順序時，這依舊是個難題 - 在網路世界中，資料未必能照你的想法依序取得</p>
<h2 id="javascript-引擎架構"><a class="header" href="#javascript-引擎架構">JavaScript 引擎架構</a></h2>
<p><img src="sections/js-core/./images/js-v8.png" alt="v8" /></p>
<p>在解釋上方的架構圖之前，先模擬一個情境：
在 C++ 中，可能使用 <code>cin</code> 或是 <code>scanf</code> 來得到使用者的輸入，若程式碼如下：</p>
<pre><code class="language-cpp">cin &gt;&gt; num;
cout &lt;&lt; &quot;Hello, world&quot; &lt;&lt; endl;
</code></pre>
<p>cin 會嘗試取得使用者輸入，然後輸出 &quot;Hello, world&quot;。但是使用者輸入之前，畫面是<strong>不會</strong>繼續渲染的，這在交互式的 command interface 不是問題，但是到了 GUI 卻相當嚴重；
比方說登入頁面，在你輸入帳號、密碼之前，畫面上其他部分都停止繪製，這聽起來很可怕對嗎？
因此瀏覽器採用的做法是&quot;事件驅動&quot;，透過觀察者模式 <em>(設計模式的一種，不贅述)</em>，等待用戶發出的事件，並進行響應</p>
<p>比方說</p>
<pre><code class="language-html">&lt;button onclick=&quot;alert('My name is Alex')&quot;&gt;Click Me&lt;/button&gt;
</code></pre>
<p>當點下按鈕後，會push <code>clickEvent</code> 至事件佇列(Event Queue)，觀察 EventLoop，他是一個無窮迴圈，會不斷檢查事件佇列，若裡頭有資料，生成Task給後面的執行緒</p>
<p>這就是關鍵所在，因為不知道使用者何時輸入/點擊畫面，因此需要用某種機制來控制渲染的執行緒、網路請求執行緒、JS執行緒，讓他們在正確的時間點運作</p>
<p>有了這個概念，再追加補充：JavaScript有分成 <code>main thread</code> 與 <code>job thread</code>(或者說是 worker, task thread)，而所有的非同步事件會先扔至 <code>job thread</code>，靜待瀏覽器調用</p>
<p>比方說 <code>setTimeout(fn, ms)</code>，接受一個function和毫秒的數值，就會在 N 毫秒後調用該方法</p>
<pre><code class="language-js">setTimeout(() =&gt; console.log('test'), 1000) // 1秒後印出 'test'
</code></pre>
<p>實際上的原理如下(大致上相同)：</p>
<ol>
<li>一開始，瀏覽器會初始化一個 timer，紀錄經過的毫秒數</li>
<li>呼叫<code>setTimeout</code>時，放置一個事件在 <code>job thread</code></li>
<li>每次 Eventloop 的週期，把<code>main thread</code>的工作結束後，檢查<code>job thread</code></li>
<li>如果<code>job thread</code>裡面有事件，檢查註冊的時戳，並比較<code>Now() - timestamp</code>是不是已經逾時了</li>
<li>如果上述為真，代表事件應該要執行了，調用它</li>
<li>回到步驟3</li>
</ol>
<p>比方說設定了 <code>setTimeout(fn, 1000)</code>, 此時註冊是時間是12:00:00，當12:00:01時，相減得到 1000， <code>1000 &gt;= 1000</code>，調用 fn</p>
<p>假設有個情境如下：要輸出1 ~ 5，每一秒輸出一個數字，程式設計如下：</p>
<pre><code class="language-js">setTimeout(() =&gt; console.log(1), 1000);
setTimeout(() =&gt; console.log(2), 2000);
setTimeout(() =&gt; console.log(3), 3000);
setTimeout(() =&gt; console.log(4), 4000);
setTimeout(() =&gt; console.log(5), 5000);
</code></pre>
<p>這時候，&quot;好像&quot;跟預期的一樣，但是要證明幾點：</p>
<p>首先，如何證明<code>main thread結束後，才會執行job thread的工作</code>？
證明如下：已知<code>setTimeout</code>會把事件放入job thread，那可以先設定<code>setTimeout(fn, 0)</code>;</p>
<pre><code class="language-js">let arr = [];
setTimeout(() =&gt; arr.push(1), 0); // job thread
setTimeout(() =&gt; arr.push(2), 0); // job thread
setTimeout(() =&gt; arr.push(3), 0); // job thread
arr.push(4) // main thread
console.log(arr) // [4,1,2,3]
</code></pre>
<p>這個程式碼的意義是：因為前面三次push是放在<code>job thread</code>的，因此狀況就好像：</p>
<pre><code class="language-js">JobThread = [fn, fn, fn];
MainThread = [fn];
</code></pre>
<p>必須等到 <code>MainThread</code> 清空後，才會依序執行 <code>job thread</code> 內的工作</p>
<p>其次，<code>每次loop都會去檢查時戳，決定要不要執行job</code>這個描述有點模糊，應該這樣說：
<code>setTimeout</code> 如果設定 ms = 1000，<code>是1000毫秒後執行</code>，還是<code>至少1000毫秒後</code>執行，這個證明有兩個方法：</p>
<p>首先定義基準時間：</p>
<p><img src="sections/js-core/./images/timer.png" alt="timer" /></p>
<!-- markdownlint-disable MD033 -->
<p>在我的電腦上，執行 3 * 10<sup>9</sup>次 空迴圈大約耗時 1500ms，接下來分別推入5個事件到<code>job thread</code>中：</p>
<p>使用 <code>performance.now</code>取得分頁開啟後的累積時間，並透過 <code>setTimeout</code> 放入 <code>job thread</code></p>
<p><img src="sections/js-core/./images/timer2.png" alt="timer2" /></p>
<p>測試方法如下：先定義 <code>diffTime</code>，他會計算陣列前後項的時間差，相當於是 <code>setTimeout</code> 放入時戳的差值</p>
<p>首先定義五個 job，都是放入一個時戳到<code>timestamps[]</code>中，最後手動呼叫 <code>diffTime</code></p>
<p>可以看到每一次的時間間隔大概是 90~100ms 左右</p>
<p>接下來設計一個實驗：</p>
<pre><code class="language-js">function diffTime(arr) {
  for(let i = 0; i &lt; arr.length - 1 ; ++i) {
    console.log(`time pass: ${arr[i+1] - arr[i]} ms`);
  }
}

// 放入5個 Task 到 job thread 中
let timestamps = [];
setTimeout(() =&gt; { timestamps.push(performance.now())}, 100);
setTimeout(() =&gt; { timestamps.push(performance.now())}, 200);
setTimeout(() =&gt; { timestamps.push(performance.now())}, 300);
setTimeout(() =&gt; { timestamps.push(performance.now())}, 400);
setTimeout(() =&gt; { timestamps.push(performance.now())}, 500);

// 使用 for-loop，阻塞 main thread 1500ms 左右
console.time(&quot;timer&quot;)
for(let i = 0 ; i &lt; 3 * 1e9 ; ++i) {}
console.timeEnd(&quot;timer&quot;)

// diffTime(timestamps) 最後手動呼叫，查看每個元素被放入的時間差
</code></pre>
<div style="display:flex; justify-content: center;">
  <img src="sections/js-core/./images/timer3.png" />
</div>
<p>這個結果的意義是：</p>
<ul>
<li>假定在 <code>t0</code> 的時候執行腳本</li>
<li>分別設定事件：放入時戳到 <code>timestamps</code> 中，分別在 <code>t0 + (100 ~ 500)ms</code> 的5個時間點</li>
<li>然後腳本繼續往下，使用 <code>for-loop</code> 阻塞 <code>main thread</code> 1492ms</li>
<li>在 <code>t0 + 1492ms</code> 的時間點後，清空 <code>main thread</code> 的所有操作</li>
<li>此時檢查 <code>job thread</code> 中的 task，發現 5 個 Task 都逾時了</li>
<li>依序執行 5 個 Task</li>
</ul>
<p>也許有點複雜，但是想驗證的核心概念：<strong>唯有當 main thread 執行結束後，才會執行job thread 中的Task</strong>已被證明</p>
<p>另外還有兩個單純的測試方法：</p>
<p>首先執行，會看到大約每間隔一秒，畫面會輸出一個數字</p>
<pre><code class="language-js">setTimeout(() =&gt; console.log(1), 1000);
setTimeout(() =&gt; console.log(2), 2000);
setTimeout(() =&gt; console.log(3), 3000);
setTimeout(() =&gt; console.log(4), 4000);
setTimeout(() =&gt; console.log(5), 5000);
</code></pre>
<p>接下來改成執行：</p>
<pre><code class="language-js">setTimeout(() =&gt; console.log(1), 1000);
setTimeout(() =&gt; console.log(2), 2000);
setTimeout(() =&gt; console.log(3), 3000);
setTimeout(() =&gt; console.log(4), 4000);
setTimeout(() =&gt; console.log(5), 5000);
window.alert('block!');
</code></pre>
<p><code>alert</code> 會跳出一個提示框，他會強制阻塞<code>main thread</code>，等到5秒後把提示框給點掉</p>
<p><img src="sections/js-core/./images/alert.png" alt="alert" /></p>
<p>然後再看看 <code>console.log</code> 的輸出，會發現1~5會<strong>同時</strong>輸出；</p>
<p>還有一個非常簡單暴力的作法：</p>
<pre><code class="language-js">while(true) {}
setTimeout(() =&gt; console.log(), 0); // 永不執行，因為 main thread 被 while-loop 永遠阻塞
</code></pre>
<h2 id="關於-settimeout-或-setinterval"><a class="header" href="#關於-settimeout-或-setinterval">關於 setTimeout 或 setInterval</a></h2>
<p>前述的例子中，有點像是證明 <code>main thread</code> 與 <code>job thread</code> 的關係，如果只是證明：setTimeout和setInterval 是至少 N 毫秒後執行</p>
<p>可以透過 console.time 和 console.timeEnd 兩組函數，觀測瀏覽器回傳的時間差異</p>
<p><img src="sections/js-core/./images/timer4.png" alt="alert" /></p>
<p>如圖所示，計時開始與結束的時間是 1019ms，實際上與 1000ms 還是有一點誤差</p>
<h2 id="章節回顧-6"><a class="header" href="#章節回顧-6">章節回顧</a></h2>
<p>本節提到幾個點：事件驅動與非同步程式設計，並以下載資料為例子，指出了在網路程式設計中，有無法預測的部分</p>
<p>比方說檔案下載完成的順序、硬碟讀取完成的時間點等</p>
<p>為了鋪陳下個章節<code>非同步程式設計</code>，該章節花了滿大的篇幅說明JS的內部架構</p>
<ul>
<li>對於<code>非同步</code>有基礎的認識</li>
<li>能夠理解事件驅動的概念</li>
<li>能夠理解 JS 中的 <code>main thread</code> 與 <code>job thread</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="非同步程式設計"><a class="header" href="#非同步程式設計">非同步程式設計</a></h1>
<p>上個章節，快速地概覽了JS的引擎，並了解事件迴圈的機制</p>
<p>在本章節之前，先用一個簡單的例子，說明一下&quot;非同步&quot;的情境</p>
<p>試想一下，某個假日起床後，打算做以下幾件事情：</p>
<ul>
<li>刷牙洗臉 (5分鐘)</li>
<li>享用早餐 (25分鐘)</li>
<li>上廁所 (15分鐘)</li>
<li>洗衣服 (1小時15分鐘)</li>
</ul>
<p>在每個事件，註記上該工作所需要的時間，假設一早起來先盥洗後，放下衣服去洗，上個廁所，然後享用早餐</p>
<p>在&quot;同步&quot;的情況下，會發生以下的狀況：</p>
<p>當盥洗後去洗衣服時，即使肚子餓了也不能用早餐；亦不能去上廁所，因為<strong>洗衣服</strong>是個<strong>阻塞事件</strong></p>
<p>換句話說，當執行一個 Task，且該 Task 不可被中斷 <strong>(阻塞 Block)</strong>，就可以粗略地說是同步程式</p>
<p>實際上的情況會更加複雜，因為會區分為：</p>
<ul>
<li>同步 (Synchronize)</li>
<li>非同步 (Asynchronize)</li>
<li>阻塞 (block)</li>
<li>非阻塞 (non-block)</li>
</ul>
<p>但在這裡不討論如此深入，先理解第一個概念： <strong>在程式中，所有的Task都是不可中斷的，就可以說是同步程式設計</strong></p>
<p>這裡只是帶出一個概念而已，實際上要看系統如何設計</p>
<h2 id="現實中的狀況"><a class="header" href="#現實中的狀況">現實中的狀況</a></h2>
<p>在生活中，也有很多非同步的情境：</p>
<ul>
<li>以上個例子來說，當把衣服丟進洗衣機洗後，就會離開做其他事情了</li>
<li>煮泡麵時，通常不會倒水後，還繼續等待三分鐘都不做其他事情</li>
<li>去銀行時，先抽取號碼牌，等到輪到自己的號碼，才去櫃檯</li>
</ul>
<p>試想一下上面的幾個情境：洗衣服時，要在洗衣機旁等待1小時；去銀行時，要在櫃台排隊直到自己到櫃檯前...</p>
<p>這些都是很浪費時間的情況，而以程式設計來說，通常非同步設計會用在</p>
<ul>
<li><strong>I/O</strong> 發生時(非常重要)</li>
<li>某個操作耗費時間甚鉅</li>
</ul>
<p>倘若假設 CPU 進行資料的運算需要 10µs，而等待硬碟把資料傳輸到記憶體需要 1 ms</p>
<p>客觀來說，耗時約為 1ms + 10µs = 1.01ms；對於CPU來說，絕大多數的時間都在<strong>等待</strong>資料傳輸</p>
<p>對於網頁設計來說，經典的例子是：當網頁上有圖片需要顯示時，不會等待圖片下載完成，而是會先渲染頁面的其餘部分</p>
<hr />
<h2 id="ajax"><a class="header" href="#ajax">AJAX</a></h2>
<p>簡單說明一下：政府有提供一系列的開放資料，可供查詢運輸的相關情況。<a href="https://ptx.transportdata.tw/MOTC/">MOTC API</a></p>
<p>這剛好符合即將要做的事情：透過網路，從遠端取得一些資料</p>
<p>經由 <code>https://ptx.transportdata.tw/MOTC/v2/Bus/StationGroup/InterCity?$top=3&amp;$format=JSON</code>，可以得到以下的資料：</p>
<div class="table-wrapper"><table><thead><tr><th>識別碼</th><th>站點代碼</th><th>站點名稱</th><th>經度</th><th>緯度</th><th>更新時間</th></tr></thead><tbody>
<tr><td>THB100－006</td><td>100-006</td><td>台電大樓</td><td>121.53</td><td>25.01</td><td>2022-07-31T07:15:28+08:00</td></tr>
<tr><td>THB100－009</td><td>100-009</td><td>仁愛新生路口</td><td>121.53</td><td>25.03</td><td>2022-07-31T07:15:28+08:00</td></tr>
<tr><td>THB100－013</td><td>100-013</td><td>捷運忠孝新生站</td><td>121.53</td><td>25.04</td><td>2022-07-31T07:15:28+08:00</td></tr>
</tbody></table>
</div>
<p>倘若是將該表格做成網頁，內容可能會是：</p>
<pre><code class="language-html">&lt;html&gt;
  &lt;body&gt;
    &lt;div&gt;
      &lt;!-- 其他資料 --&gt;
    &lt;/div&gt;
    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;識別碼&lt;/th&gt;
          &lt;th&gt;站點代碼&lt;/th&gt;
          &lt;th&gt;站點名稱&lt;/th&gt;
          &lt;th&gt;經度&lt;/th&gt;
          &lt;th&gt;緯度&lt;/th&gt;
          &lt;th&gt;更新時間&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;THB100－006&lt;/td&gt;
          &lt;td&gt;100-006&lt;/td&gt;
          &lt;td&gt;台電大樓&lt;/td&gt;
          &lt;td&gt;121.53&lt;/td&gt;
          &lt;td&gt;25.01&lt;/td&gt;
          &lt;td&gt;2022-07-31T07:15:28+08:00&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;THB100－009&lt;/td&gt;
          &lt;td&gt;100-009&lt;/td&gt;
          &lt;td&gt;仁愛新生路口&lt;/td&gt;
          &lt;td&gt;121.53&lt;/td&gt;
          &lt;td&gt;25.03&lt;/td&gt;
          &lt;td&gt;2022-07-31T07:15:28+08:00&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;THB100－013&lt;/td&gt;
          &lt;td&gt;100-013&lt;/td&gt;
          &lt;td&gt;捷運忠孝新生站&lt;/td&gt;
          &lt;td&gt;121.53&lt;/td&gt;
          &lt;td&gt;25.04&lt;/td&gt;
          &lt;td&gt;2022-07-31T07:15:28+08:00&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
    &lt;div&gt;
      &lt;!-- 其他資料 --&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>這個假設的網頁，可能還包含了該表格以外的資料，使用 <code>&lt;!-- 其他資料 --&gt;</code> 替代，</p>
<p>假設上面的表格是會更新的(Ex. 每 30 分鐘一次)，每次都需要重新要求整個頁面，是很浪費效能的</p>
<p>因為用戶只關心<strong>會變化的資料</strong>，比方說上面的<em>表格</em></p>
<p>在之後，會說明什麼是<strong>RestAPI</strong>，因此這裡先不解釋，只需要先知道一件事情：</p>
<p>網頁依賴另一個伺服器的資料，且這個資料在網頁上<code>可能</code>會常常變化</p>
<h2 id="早期的實現"><a class="header" href="#早期的實現">早期的實現</a></h2>
<p>在過去 YAHOO 帳號還很流行的時候，許多人都會去辦一組信箱：</p>
<p>若你忘記流程了，我稍微複習一下</p>
<ul>
<li>輸入一個帳號名稱</li>
<li>輸入你的姓名、基本資料</li>
<li>送出表單</li>
<li>喔，你有可能帳號名稱跟別人重複了、或是密碼不符合格式(比方說要包含大小寫英數字)</li>
</ul>
<p>在隨後幾年(2010)，Google 進入大家的生活，同樣的流程：</p>
<ul>
<li>輸入一個帳號名稱</li>
<li>準備輸入你的姓名、基本資料</li>
<li><strong>已經知道該帳號有沒有被註冊過了</strong></li>
<li>填寫其他項目...</li>
</ul>
<p>這在現今很常見的情況，是由 Google 所發揚的技術之一 - AJAX</p>
<p>早在 Google 使用該方法之前，早就有這項技術，全名叫做 <code>Asynchronous JavaScript And XML(AJAX)</code></p>
<p>概念十分單純：平常使用的網頁，其實大部分的版面是固定的，僅有一小部分會變化，比方說：</p>
<ul>
<li>圖書館館藏系統：只有搜尋結果的部分會改變</li>
<li>帳號註冊系統：表單都是一樣的，只是要檢查帳號、密碼合不合格</li>
<li>Youtube：搜尋影片時，只有下方的影片清單會改變</li>
</ul>
<p>諸多應用，因此提出一個概念：<strong>能不能只交換需要的部分？</strong></p>
<p>因為早期使用XML做為資料傳輸的格式(近幾年幾乎都改用JSON)，所以稱為AJAX</p>
<p>概念如下：我透過背景發起網路I/O，並等到伺服器回應後，再把資料取出來使用，實現的程式碼如下</p>
<pre><code class="language-js">const domain = 'ptx.transportdata.tw';
const apiPath = 'MOTC/v2/Bus/StationGroup/InterCity';
const query = '$top=3&amp;$format=JSON';

const targetUrl = `https://${domain}/${apiPath}?${query}`;

let xhr = new XMLHttpRequest();

/* xhr.open(method, url) 以特定的HTTP方法開啟某個網址 */
xhr.open('get', targetUrl);

/* 當資料完成後，要做什麼事情 */
xhr.onload = function(e) {
  console.log(xhr.responseText);
}
/* 等校的程式碼：
xhr.addEventListener('load', e =&gt; {
  console.log(xhr.responseText);
}) */

/* 送出請求 */
xhr.send();
</code></pre>
<p>看到 <code>onload</code>，就知道當完成後，會發送一個事件，通知應該去取得資料</p>
<h2 id="現在的做法"><a class="header" href="#現在的做法">現在的做法</a></h2>
<p>在ES 6(ECMA 2016)之後，推出了一系列的API，其中影響距甚的就有 <code>Promise</code></p>
<p>而ES 7之後，則推出了 <code>async/await</code> ，更方便進行處理</p>
<h2 id="promise"><a class="header" href="#promise">Promise</a></h2>
<p>Promise 的含意是：一個未來的值，且當狀態決定之後，絕對不會改變</p>
<p>這有一些抽象，用實際的例子來說明，首先是 Promise 的函式簽章：</p>
<pre><code class="language-js">
function executor( resolve, reject ) {
  /* do something */
}

let promise = new Promise( executor );

</code></pre>
<p><code>executor</code> 的型別是 <code>Function</code>，並接受兩個參數 <code>resolve</code> 和 <code>reject</code>，兩個參數都是 <code>function</code></p>
<p>resolve 的意義是：當操作成功，應該調用該方法</p>
<p>reject 的意義是：當操作失敗，應該調用該方法</p>
<p>這個用法十分常見，這裡先補充一下</p>
<pre><code class="language-js">function calc( callback ) {
  let a = Math.random() * 100;
  let b = Math.random() * 100;
  return callback(a, b);
}

function add(a, b) {
  return a + b;
}

function mul(a, b) {
  return a * b;
}

calc(add) // return `Math.random() * 100` + `Math.random() * 100` 的值
calc(mul) // return `Math.random() * 100` * `Math.random() * 100` 的值
</code></pre>
<p>在 JavaScript，很常 Function 的參數是接受一個 Function</p>
<p>呼叫 calc 時，calc內部會生成兩個隨機數字 <code>a</code>, <code>b</code>，並傳入 <code>callback</code> 這個 Function</p>
<p>而 add 和 mul 常這兩個被傳入的function，常被叫做 <code>callback</code> 或是 <code>handler</code>，比方說滑鼠點擊事件的函數簽章：</p>
<pre><code class="language-js">htmlElement.addEventListener('click', e =&gt; {
  console.log(e);
})
</code></pre>
<p><code>addEventListener</code> 接收兩個參數：第一個是事件種類，常用的有 <code>click</code>, <code>change</code>, <code>load</code> ... 等</p>
<p>第二個參數則是一個 <code>handler</code>，他會把事件物件傳給 <code>handler</code>，供 <code>handler</code>使用</p>
<p>那麼回到 <code>Promise</code>，可以理解成 <code>Promise</code> 內部會生成兩個 <code>callback</code> 供使用</p>
<p>這使得可以決定 <code>Promise</code> 的狀態是成功的還是失敗的：</p>
<pre><code class="language-js">let promise = new Promise((resolve, reject) =&gt; {
  const value = Math.random() * 1000;
  if(value &gt; 500)
    resolve(value);
  else
    reject(value);
});
</code></pre>
<p><code>new Promise</code> 回傳的實例，會提供 <code>then</code> 或是 <code>catch</code> 方法，分別對應 <code>resolve</code> 和 <code>reject</code> ：</p>
<pre><code class="language-js">promise
  .then(value =&gt; console.log(value))   // 當 resolve 被調用時，進入該函式
  .catch(value =&gt; console.log(value)); // 當 reject 被調用時，進入該函式
</code></pre>
<p>這樣理解Promise：一個未來會存在的數值，且狀態確定後，就不會改變了</p>
<p>狀態不會改變的意思是：</p>
<pre><code class="language-js">let promise = new Promise((resolve, reject) =&gt; {
  const flag = true;
  resolve(true);
  reject(false); // 無效，已經呼叫了 resolve
});

promise
  .then(value =&gt; console.log(value))  // print 'true';
  .catch(value =&gt; console.log(value)) // 不會執行
</code></pre>
<p>這個就是 Promise 不變性的意思：</p>
<ul>
<li>一開始處於 pending 狀態：還未調用 <code>resolve</code> 或是 <code>reject</code> 之前，都處於該狀態</li>
<li>當 resolve 調用後：成為 fulfilled(實現) 狀態</li>
<li>當 reject 調用後：成為 rejected(拒絕) 狀態</li>
</ul>
<p>Promise 一旦被決定是 fulfilled 還是 rejected 後，就不會變成其他狀態了
而 Promise 只會被決定<strong>一次</strong>狀態，意思是：</p>
<pre><code class="language-js">let promise = new Promise((resolve, reject) =&gt; {
  const flag = true;
  resolve(true);  // 在該階段，Promise 成為 fulfilled 狀態
  resolve(false); // 無效，Promise的狀態已經被決定了
});
</code></pre>
<p>而 <code>then</code> 和 <code>catch</code> 的回傳值，會成為下一個 <code>Promise</code> 的值：</p>
<pre><code class="language-js">
let promise = new Promise((resolve, reject) =&gt; {
  resolve(10); // 必定會成功的 Promise
});

promise
  .then(value =&gt; {
    console.log(value); // print 10
    return value * 100
  })
  .then(value =&gt; {
    console.log(value); // print 1000
  });
</code></pre>
<p>且 Promise 有個特性：他可以類似串列一般，把本次的回傳值做為下一個promise的傳入</p>
<pre><code class="language-js">let promise = new Promise((resolve, reject) =&gt; {
  const flag = Math.random() &gt; 0.5; // Math.random() 會隨機回傳 0~1 之間的數字
  if(flag) {
    resolve(1,2,3,4,5) // 僅接受第一個參數
  } else {
    reject(10,20,30) // 僅接受第一個參數
  }
});

promise
  .then((a,b,c,d,e) =&gt; {
    console.log(a,b,c,d,e); // print 1, undefined * 4
    return 100;
  })
  .catch((a,b,c) =&gt; {
    console.log(a,b,c); // print 10, undefined * 2
    return -100;
  })
  .then( value =&gt; {
    // 如果 flag 為 true，代表進入上一個 then，此時 value = 100
    // 反之 flag 為 false，代表進入上一個 catch，此時 value = -100
    console.log(value);
    return 10000
  })
  .finally(e =&gt; {
    // 可以調用 finally()，代表不論在 then 還是 catch 都要執行的事件
    console.log(e) // undefined，finally不接受任何參數
  })
</code></pre>
<p>Promise的出現，為帶來了一個重要的進展 - 可以針對非同步事件進行排序</p>
<p>以上個個章節的例子，要下載 fileA, fileB, fileC，且一定要依照A B C的順序</p>
<p>在上個章節，用<code>arr[0]、arr[1]、arr[2]</code>分別存入A、B、C的值，但是使用 Promise 後，可以改為：</p>
<pre><code class="language-js">function download(url) {
  return new Promise( (resolve, reject) =&gt; {
    const xhr = new XMLHttpRequest();
    xhr.open('get', url);
    xhr.addEventListener('load', () =&gt; {
      resolve(xhr.responseText) // 下載完成後，調用 resolve
    })
    xhr.addEventListener('error', e =&gt; {
      reject(e.message) // 若失敗，調用 reject
    });
    xhr.send() //送出請求
  })
}


function downloadABC() {
  download(siteA)
    .then(data =&gt; {
      console.log(data);
      return download(siteB);
    })
    .then(data =&gt; {
      console.log(data);
      return download(siteC);
    })
    .then(data =&gt; {
      console.log(data);
    });
}

downloadABC() //依序呼叫 siteA、siteB、siteC 的下載內容
</code></pre>
<h2 id="更深入的-promise"><a class="header" href="#更深入的-promise">更深入的 Promise</a></h2>
<p><img src="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/promises.png" alt="Promise" /></p>
<p>這裡直接引用 MDN 的 Promise 流程圖：起初在 <code>pending</code> 狀態，接下來根據 <code>fulfill</code> 或是 <code>reject</code>，調用 <code>onFulfillment</code> 或是 <code>onRejection</code>，此時就被稱為 <code>settled</code> 狀態</p>
<p>值得注意的地方是，可以看到其實 <code>then()</code> 是可以接受兩個 callback：</p>
<pre><code class="language-js">const invokeFn = () =&gt; Promise.reject(&quot;oops!&quot;)

/* Example 1 */
invokeFn()
  .then(
    () =&gt; console.log(&quot;onFulfillment&quot;),
    reason =&gt; console.log(`onReject ${reason}`)
  )
  .catch(
    reason =&gt; console.log(`ErrorCatch, ${reason}`)
  );

/* Example 2 */
invokeFn()
  .then(
    () =&gt; console.log(&quot;onFulfillment&quot;),
  )
  .catch(
    reason =&gt; console.log(`ErrorCatch, ${reason}`)
  );
</code></pre>
<p><img src="sections/js-core/./images/../Promise.png" alt="Promise" /></p>
<p>在舊一點的實作中，會特意把 <code>fulfill</code>, <code>reject</code>, <code>error</code> 三種情況分開，舉例來說，當呼叫伺服器的API時，可能會發生<code>200 OK</code>, <code>403 Forbidden</code>，跟無回應：也就是有三種可能的情況，伺服器收到請求並允許、伺服器收到請求並拒絕、完全無回應</p>
<p>那對於客戶端來說，<code>onFulfillment</code> 對應到 <code>status 200</code>，<code>onReject</code> 對應到 <code>status 403</code>，最後<code>onCatchError</code> 對應到伺服器無回應</p>
<ul>
<li>Promise.resolve(val) 回傳一個進入 <code>fulfill</code> 狀態的 Promise 物件</li>
<li>Promise.reject(val) 回傳一個進入 <code>reject</code> 狀態的 Promise 物件</li>
</ul>
<p>注意流程圖的第三階段，無論是 <code>then</code> 還是 <code>catch</code> 方法，都會會傳一個新的 <code>Promise</code> 物件</p>
<h2 id="進階練習"><a class="header" href="#進階練習">進階練習</a></h2>
<p>這就如上方的 <code>downloadABC</code> 例子，每一次的 then 都會回傳一個新的 Promise 物件，又Promise 只會被決定一次狀態，因此可以提出兩種變體：</p>
<p>首先定義一個<strong>模擬下載</strong>  的Promise函式，他接受兩個值：val 以及 isSuccess</p>
<pre><code class="language-js">/* val 設定成當 Promise settled 時，應該回傳的值 */
/* isSuccess 則決定，該 Promise 的狀態是 `fulfill` 還是 `reject` */
const download = (val, isSuccess = true) =&gt; {
  if(isSuccess) {
    return Promise.resolve(`Fulfill: ${val}`);
  } else {
    return Promise.reject(`Reject: ${val}`);
  }
}

download(&quot;data A&quot;)
  /* stage 1 */
  .then(data =&gt; {
    console.log(`Savepoint 1: ${data}`);
    return download(&quot;data B&quot;);
  })
  .catch(err =&gt; {
    console.log(`Savepoint 2: ${err}`);
    return download(&quot;error-data B&quot;);
  })
  /* stage 2 */
  .then(data =&gt; {
    console.log(`Savepoint 3: ${data}`);
    return download(&quot;data C&quot;);
  })
  .catch(err =&gt; {
    console.log(`Savepoint 4: ${err}`);
    return download(&quot;error-data C&quot;);
  })
  /* stage 3 */
  .then(data =&gt; {
    console.log(`Savepoint 5: ${data}`);
  })
  .catch(err =&gt; {
    console.log(`Savepoint 6: ${err}`);
  })
</code></pre>
<p>這個例子看起來非常複雜對嗎？但是可以經過簡單的拆解，理清這個範例的執行結果：</p>
<p>在第一次呼叫 download 時，第二個參數 <code>isSuccess</code> 為 true，因此該次執行結果是 <code>fulfill</code></p>
<pre><code class="language-js">download(&quot;data A&quot;) // fulfill
</code></pre>
<p>此時會經過 <code>Savepoint 1</code>，並印出 &quot;Savepoint 1: Fulfill: data A&quot;
下一行的 <code>download(&quot;data B&quot;)</code> 也是 <code>fulfill</code>，因此會略過 catch，進入到 <code>stage 2</code> 的 <code>Savepoint 3</code>，並印出 &quot;Savepoint 3: Fulfill: data B&quot;</p>
<p>同樣的，最後則會走到 <code>stage 3</code> 的 &quot;Savepoint 5&quot;，並印出 &quot;Savepoint 5: Fulfill: data C&quot;</p>
<p>最終輸出：</p>
<pre><code class="language-text">Savepoint 1: Fulfill: data A
Savepoint 3: Fulfill: data B
Savepoint 5: Fulfill: data C
</code></pre>
<p>其實有個大原則：只要找當下離當下 <code>Promise</code> 最近的 <code>then</code> 和 <code>catch</code>，再根據 settled 的狀態決定路徑</p>
<p>下面的例子，會把&quot;看不到&quot;的路徑，先註解起來</p>
<pre><code class="language-js">download(&quot;data A&quot;) // &lt;--- 目前執行的位置
  /* stage 1 */
  .then(data =&gt; { // &lt;--- 最近的 then
    console.log(`Savepoint 1: ${data}`);
    return download(&quot;data B&quot;);
  })
  .catch(err =&gt; { // &lt;--- 最近的 catch
    console.log(`Savepoint 2: ${err}`);
    return download(&quot;error-data B&quot;);
  })
  /* stage 2 */
  // .then(data =&gt; {
  //   console.log(`Savepoint 3: ${data}`);
  //   return download(&quot;data C&quot;);
  // })
  // .catch(err =&gt; {
  //   console.log(`Savepoint 4: ${err}`);
  //   return download(&quot;error-data C&quot;);
  // })
  /* stage 3 */
  // .then(data =&gt; {
  //   console.log(`Savepoint 5: ${data}`);
  // })
  // .catch(err =&gt; {
  //   console.log(`Savepoint 6: ${err}`);
  // })
</code></pre>
<p>該次結果是成功，因此會進到 then，此時在 <code>Savepoint 1</code>：</p>
<pre><code class="language-js">// download(&quot;data A&quot;) 
  /* stage 1 */
  .then(data =&gt; { 
    console.log(`Savepoint 1: ${data}`);
    return download(&quot;data B&quot;); // &lt;--- 目前執行的位置
  })
  .catch(err =&gt; { // &lt;--- 最近的 catch
    console.log(`Savepoint 2: ${err}`);
    return download(&quot;error-data B&quot;);
  })
  /* stage 2 */
  .then(data =&gt; { // &lt;--- 最近的 then
    console.log(`Savepoint 3: ${data}`);
    return download(&quot;data C&quot;);
  })
  // .catch(err =&gt; {
  //   console.log(`Savepoint 4: ${err}`);
  //   return download(&quot;error-data C&quot;);
  // })
  /* stage 3 */
  // .then(data =&gt; {
  //   console.log(`Savepoint 5: ${data}`);
  // })
  // .catch(err =&gt; {
  //   console.log(`Savepoint 6: ${err}`);
  // })
</code></pre>
<p>這次結果也是成功，因此會進到 then，此時在 <code>Savepoint 3</code>：</p>
<pre><code class="language-js">// download(&quot;data A&quot;) 
  /* stage 1 */
  // .then(data =&gt; { 
  //   console.log(`Savepoint 1: ${data}`);
  //   return download(&quot;data B&quot;);
  // })
  // .catch(err =&gt; {
  //   console.log(`Savepoint 2: ${err}`);
  //   return download(&quot;error-data B&quot;);
  // })
  /* stage 2 */
  .then(data =&gt; { 
    console.log(`Savepoint 3: ${data}`);
    return download(&quot;data C&quot;); // &lt;--- 目前執行的位置
  })
  .catch(err =&gt; {
    console.log(`Savepoint 4: ${err}`);
    return download(&quot;error-data C&quot;);  // &lt;--- 最近的 catch
  })
  /* stage 3 */
  .then(data =&gt; { // &lt;--- 最近的 then
    console.log(`Savepoint 5: ${data}`);
  })
  // .catch(err =&gt; {
  //   console.log(`Savepoint 6: ${err}`);
  // })
</code></pre>
<p>最後的結果還是成功，因此會進到 then，此時在 <code>Savepoint 5</code>：</p>
<p>可以修改範例，比方說，在 <code>stage 1</code> 的 <code>then</code> 扔出一個 Error：</p>
<pre><code class="language-js">download(&quot;data A&quot;)
  /* stage 1 */
  .then(data =&gt; {
    console.log(`Savepoint 1: ${data}`);
    throw &quot;Something wrong&quot; // &lt;------- 加入該行
    return download(&quot;data B&quot;);
  })
  .catch(err =&gt; {
    console.log(`Savepoint 2: ${err}`);
    return download(&quot;error-data B&quot;);
  })
  /* stage 2 */
  .then(data =&gt; {
    console.log(`Savepoint 3: ${data}`);
    return download(&quot;data C&quot;);
  })
  .catch(err =&gt; {
    console.log(`Savepoint 4: ${err}`);
    return download(&quot;error-data C&quot;);
  })
  /* stage 3 */
  .then(data =&gt; {
    console.log(`Savepoint 5: ${data}`);
  })
  .catch(err =&gt; {
    console.log(`Savepoint 6: ${err}`);
  })
</code></pre>
<p>此時的輸出順序就會是</p>
<pre><code class="language-text">Savepoint 1: Fulfill: data A
Savepoint 2: Something wrong
Savepoint 3: Fulfill: error-data B
Savepoint 5: Fulfill: data C
</code></pre>
<p>更多資料請參考 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Promise">MDN - Promise</a></p>
<h2 id="fetch"><a class="header" href="#fetch">fetch</a></h2>
<p>ES 6 也提供了 <code>fetch</code> API，他就像是上面的 <code>download</code> 的實作，只是是由瀏覽器提供的WebAPI：</p>
<pre><code class="language-js">const result = fetch(url, {
  method,  // HTTP Method, default 為 get
  headers, // HTTP 表頭, default為null
  body,     // 內容, default為null
  ...moreOptions
});

result.then(e =&gt; {
  return e.json() //把資料以JSON格式解讀
})
.then(json =&gt; {
  console.log(json)
});
</code></pre>
<p>這就是最常用來抓取伺服器資料的方法，比方說上面那個抓取政府運輸資料的程式可改為：</p>
<pre><code class="language-js">const domain = 'ptx.transportdata.tw';
const apiPath = 'MOTC/v2/Bus/StationGroup/InterCity';
const query = '$top=3&amp;$format=JSON';

const targetUrl = `https://${domain}/${apiPath}?${query}`;

fetch(targetUrl)
  .then(res =&gt; res.json())
  .then(data =&gt; {
    /* do something */
    console.log(data) // 印出資料
  });
</code></pre>
<p>執行結果
<img src="sections/js-core/./images/response.png" alt="response" /></p>
<p><strong>Note!</strong> 如果請求的站點出現<code>404 NOT FOUND</code>，那麼fetch的結果是 <strong>fulfilled</strong></p>
<p>原因：fetch代表的是對伺服器<strong>發出請求</strong>，而不是取得資料，而404 status一樣是伺服器的回傳結果</p>
<pre><code class="language-js">fetch(&quot;httpp://www.google.com&quot;)
  .then(d =&gt; {
    console.log(true);
  })
  .catch(err =&gt; {
    console.log(&quot;Error&quot;)
  }) //進入 catch
</code></pre>
<p>這個例子中，誤把 <code>http</code> 打成 <code>httpp</code>，一個未知的協定，因此無法發出請求
導致直接進入 catch 階段</p>
<pre><code class="language-js">const domain = 'ptx.transportdata.tw';
const apiPath = 'MOTC/v2/Bus/StationGroup/InterCity';
const query = '$top=3&amp;$format=JSON';

const targetUrl = `https://${domain}/${apiPath}?${query}`;

fetch(targetUrl)
  .then(res =&gt; {
    return res.text(); // 這次不使用 json()，而是使用 text() 取得未 paese 的內容
  })
  .then(content =&gt; {
    console.log(content);
    return JSON.parse(content+'}');
  })
  .catch(err =&gt; {
    // 會進入這裡，因為在 content 後加上 '}'，導致無法順利解析成JSON格式
    console.log(&quot;Parse error&quot;)
  })
</code></pre>
<p>而上述的例子中，可以觀察到在 then 或是 catch 中 <code>throw Error</code>，會進入下個階段的 catch</p>
<p>更多資料請參考 <a href="https://developer.mozilla.org/en-US/docs/Web/API/fetch">MDN - fetchAPI</a></p>
<h2 id="async-與-await"><a class="header" href="#async-與-await">async 與 await</a></h2>
<p>在前兩個章節，了解了 Promise 的使用方法，但是有個問題：Promise的回傳值永遠都是 Promise</p>
<p>因此要在外部使用<code>fetch</code>到的資料，會有點麻煩：</p>
<pre><code class="language-js">let a;

fetch(url)
  .then(res =&gt; res.json())
  .then(data =&gt; {
    a = data;
  });

function useDataA(data) {
  /* do something */
}
</code></pre>
<p>這樣就有點雞生蛋、蛋生雞，因為不知道 a 何時會就緒，因此有兩種做法：</p>
<pre><code class="language-js">// Sol 1：在 promise 內部使用 data
fetch(url)
  .then(res =&gt; res.json())
  .then(data =&gt; {
    useDataA(data);
  });

// Sol 2：使用 setInterval，每隔一段時間檢查a的狀態
let a;

fetch(url)
  .then(res =&gt; res.json())
  .then(data =&gt; {
    a = data;
  });

function useDataA() {
  // 每隔 300ms 檢查一次
  const timer = setInterval(() =&gt; {
     // a 就緒了，清除計時器
    if(a) {
      clearInterval(timer)
      /* do something */
      JSON.parse(a);
    };
  }, 300)
}
</code></pre>
<p>這對程式設計來講，是個沉重的負擔，因此在 ES 7，推出了 <code>async function</code></p>
<pre><code class="language-js">
async function add(a, b) {
  return a + b;
}

let result = add(a, b);

console.log(a) // Promise object
</code></pre>
<p>可以在 <code>function</code> 前，加上<code>async</code> 關鍵字，指示該函式成為<em>非同步函式</em></p>
<p>非同步函式有兩個特色：</p>
<ul>
<li>回傳值<strong>永遠</strong>都是 Promise 物件</li>
<li>允許使用 <code>await</code></li>
</ul>
<p>回傳值永遠都是 Promise 物件的意思是，不論 return 什麼值，async function都會包裝成 Promise</p>
<pre><code class="language-js">async function add(a, b) {
  return a + b;
}

let result = add(10, 20);

result.then(value =&gt; console.log(value)) // 會印出 30
</code></pre>
<p>這個特色滿正常的，因為他就是指示某個function是非同步事件，所以使用Promise封裝很合理；
重點是特色2</p>
<p><code>await</code> 可以取出 Promise 最後的回傳值，比方說：</p>
<pre><code class="language-js">function return100() {
  return new Promise((resolve, reject) =&gt; resolve(100));
}

// 正常使用：
return100()
  .then(data =&gt; console.log(data)) // print 100


// 在 async function 中使用 await
async function get100() {
  const result = await return100();
  console.log(result) // print 100
}
</code></pre>
<p>很神奇吧！他可以讓的非同步程式&quot;看起來&quot;像同步程式</p>
<p>如果以上面那個download A、B、C 的例子，就可以改成</p>
<pre><code class="language-js">function download(url) {
  return fetch(url)
          .then(res =&gt; res.text());
}

async function processData() {
  const dataA = await download(siteA);
  const dataB = await download(siteB);
  const dataC = await download(siteC);
}
</code></pre>
<p>如上所示，<code>processData</code>的行為就像是同步程式，那你可能有個疑問：</p>
<p><code>await</code> 對應到 <code>then</code> 方法，那麼 <code>catch</code> 呢？</p>
<p>直接使用 <code>try { ... } catch { ... }</code> 即可</p>
<pre><code class="language-js">async function processData() {
  try {
    const dataA = await download(siteA);
    const dataB = await download(siteB);
    const dataC = await download(siteC);
  } catch {
    console.log(&quot;Download Failed&quot;);
  }
}
</code></pre>
<p>這就是 <code>async/await</code> 的使用方法</p>
<p>更多資料請參考 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">MDN - async function</a></p>
<h2 id="章節回顧-7"><a class="header" href="#章節回顧-7">章節回顧</a></h2>
<p>這裡花了極大的篇幅在解釋非同步程式設計，以及 <code>Promise</code> 物件的使用方法
本章節可以說是 <strong>最重要的</strong> 概念，請務必深入理解<code>Promise</code>的概念</p>
<ul>
<li>理解非同步事件的概念</li>
<li>AJAX 的重要性</li>
<li>Promise API</li>
<li>fetch API</li>
<li>async/await 關鍵字</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="常用技巧與函數"><a class="header" href="#常用技巧與函數">常用技巧與函數</a></h1>
<p>這個部分，統整了一些常用的 JavaScript 函式及語法</p>
<h2 id="解構賦值"><a class="header" href="#解構賦值">解構賦值</a></h2>
<p>解構賦值的概念是，如果被引用的值屬於物件或是陣列，可以用同樣結構的宣告，把值取出來：</p>
<pre><code class="language-js">
const point = {
  x: 10,
  y: 20,
  z: 30
}

const { x, y, z } = point;
// x = 10 , y = 20 , z = 30
</code></pre>
<p>也可以使用別名的方式，比方說</p>
<pre><code class="language-js">const point = {
  x: 10,
  y: 20,
  z: 30
}

const { x: a, y: b, z: c } = point;
// a = 10 , b = 20 , c = 30

// 稍微排序一下
// 對照 point 的宣告，a b c 剛好在 x y z 的值上
// 因此會宣告a, b, c 三個變數分別對應到x, y ,z
const { 
  x: a,
  y: b,
  z: c
} = point;
</code></pre>
<p>陣列也可以：</p>
<pre><code class="language-js">const arr = [1,2,3,4,5,6,7,8];
const [first] = arr;
// first = 1

// 可以解構更多的值：
const [a,b,c,d,e,f,g,h] = arr;
// a = 1, b = 2, c = 3, d = 4, e = 5, f = 6, g = 7, h = 8
</code></pre>
<p>引數也可以解構：</p>
<pre><code class="language-js">const point = {
  x: 10,
  y: 20,
  z: 30
}


function getPoint({x, y, z}) {
  console.log(x, y, z);
}

getPoint(point) // print 10 20 30
getPoint({x: 100, y: 200}) // print 100 200 undefined
</code></pre>
<p>即使物件多麼複雜，只要有辦法宣告成同樣的形式，都可以解構</p>
<pre><code class="language-js">const complexObj = {
  a: {
    b: {
      c: {
        d: 100
      }
    }
  }
};

const { a: { b: { c: { d }}}} = complexObj
console.log(d) // print 100

// alias
const complexObj = {
  a: {
    b: {
      c: {
        d: 400
      }
    }
  }
};

const { a: { b: { c: { d: myVar }}}} = complexObj
console.log(myVar) // print 400
</code></pre>
<p>參考 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">Destructuring assignment</a></p>
<hr />
<p>展開運算子</p>
<p>可以使用 <code>...</code> 運算子，對物件或是迭代器進行展開：</p>
<p>陣列展開</p>
<pre><code class="language-js">let arr = [10, 20, 30, 40, 50];
let [first, ...data] = arr;
// first = 10
// data 則是把剩下的展開， data = [20, 30, 40, 50]

let [first, ...data, last] = arr //Error，展開運算子必須得要放在最後
</code></pre>
<p>物件展開</p>
<pre><code class="language-js">const point = {
  x: 10, y: 20, z: 30
}

const { x, ...other } = point
// x = 10
// other = { y: 20, z : 30 }
</code></pre>
<p>也可以在引數展開</p>
<pre><code class="language-js">function sum(a, b, c) {
  return a + b + c;
}

const arr = [1, 2, 3];
sum(...arr); //會展開成 sum(1, 2, 3)
</code></pre>
<p>反過來，也可以在參數展開</p>
<pre><code class="language-js">function sum(...numbers) {
  let res = 0;
  for(let i = 0; i &lt; numbers.length; ++i)
    res += numbers[i];
  return res;
}

sum(1,2,3,4,5,6); // return 21
</code></pre>
<p>參考 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/Spread_syntax#rest_syntax_parameters">Spread syntax</a></p>
<h3 id="進階用法"><a class="header" href="#進階用法">進階用法</a></h3>
<p>可以用來拷貝一層 array (請注意，該方法不是深拷貝，僅是拷貝一層陣列而已)</p>
<pre><code class="language-js">let arr = [1,2,3,4,5,6,7,8];
let arr2 = arr;
let arr3 = [...arr]; // 展開 arr

console.log(arr === arr2); // true
console.log(arr2 === arr3); // false
</code></pre>
<p>也可以用來合併物件or陣列：</p>
<pre><code class="language-js">let obj1 = {
  x: 10,
  y: 20
}

let obj2 = {
  a: true,
  b: false
}

let obj3 = { ...obj1, ...obj2 };
console.log(obj3) 
/* {
  x: 10,
  y: 20,
  a: true,
  b: false
} */

let arr = [1,2,3];
let arr2 = [2,3,4];

let arr3 = [...arr, ...arr2] // [1,2,3,2,3,4]
let arr4 = [...arr,...arr,...arr2,...arr]// [1,2,3,1,2,3,2,3,4,1,2,3]

/* 初始化物件的技巧 */

const defaultValue = {
  x: 100,
  y: 200,
  z: 300,
}

const obj = {
  ...defaultValue,
  z: 400
}
// obj = { x: 100, y: 200, z: 400 }

/* 要注意展開的順序 */
const obj = {
  z: 400,
  ...defaultValue,
}
// obj = { x: 100, y: 200, z: 300 }
// 因為 defaultValue 後展開，所以把原本的值又蓋掉了

</code></pre>
<h2 id="物件迭代器"><a class="header" href="#物件迭代器">物件迭代器</a></h2>
<p>在 <code>Object.prototype</code> 中，提供了幾種實用的方法</p>
<pre><code class="language-js">const obj = {
  x: 10,
  y: 20,
  a: true,
  b: false
};

let objKeyIter = Object.keys(obj); //回傳迭代器
for(const key of objKeyIter) {
  console.log(key) // 依序印出 x, y, a, b
}

for(const value of Object.values(obj)) {
  console.log(value) // 依序印出 10, 20, true, false
}

for(const pair of Object.entries(obj)) {
  console.log(pair[0], pair[1]) 
  // 依序印出:
  // x 10
  // y 20
  // a true
  // b false
}

/* 當然，上面的用法可以合併解構附值 */
for(const [key, value] of Object.entries(obj)) {
  console.log(key, value) // 結果同上
}

/* 前面有提到，迭代器可以被展開 */
let keys = [...Object.keys(obj)]  // ['x', 'y', 'a', 'b']
let value = [...Object.values(obj)] // [10, 20, true, false]
let entries = [...Object.entries(obj)] 
/*
[
  ['x', 10]
  ['y', 20]
  ['a', true]
  ['b', false]
]
*/

/* 使用 fromEntries 還原物件 */
const o = Object.fromEntries(entries) // o = obj
</code></pre>
<p>此外，諸如<code>string</code> 等也有實現迭代器，因此</p>
<pre><code class="language-js">
console.log(...'hello,world') //輸出 h e l l o , w o r l d 共11個字元

</code></pre>
<hr />
<h2 id="短路求值以及--運算子"><a class="header" href="#短路求值以及--運算子">短路求值以及 ?? 運算子</a></h2>
<p>在 JavaScript 中， boolean 判斷主要分為 <code>falsy</code> 和 <code>truthy</code></p>
<p>falsy 的意義是，在判斷式中會被當成 <code>false</code> 的值，truthy 則反之</p>
<p>只需要記得 falsy 就好，falsy的值有：</p>
<ul>
<li>false</li>
<li>0</li>
<li>-0</li>
<li>0n (bigint)</li>
<li>&quot;&quot;, '', ``  (空字串)</li>
<li>null</li>
<li>undefined</li>
<li>NaN</li>
<li>document.all</li>
</ul>
<p>其餘的都是 Truthy 值</p>
<p>而看到的 <code>||</code> 和 <code>&amp;&amp;</code> 運算子，其真正的定義如下：</p>
<pre><code class="language-js">let res = A || B //若 A 為false，才執行 B 敘述

/* Example */
let res1 = 100 || 'string' || console.log(100) // 100 是 truthy，後面不必判斷了，短路求值
let res2 = 0 || 'string' || console.log(100) // 0 是 falsy, 'string' 是 truthy，短路求值
let res3 = A() || B() || C() // 若 A() 回傳 truthy 值，則B、C 不執行

/* 以下與 res3 等價 */
if(!A()) {
  if(!B()) {
    C()
  }
}
</code></pre>
<pre><code class="language-js">let res = A &amp;&amp; B //若 A 為truthy，才執行 B 敘述

/* Example */
let res1 = false &amp;&amp; 0 &amp;&amp; console.log(100) // false 是 falsy，短路求值
let res2 = true &amp;&amp; 0 &amp;&amp; console.log(100) // true 是 truthy，0 是 falsy，短路求值
let res3 = true &amp;&amp; 100 &amp;&amp; console.log(100) // 前面兩個都是 truthy，執行 console.log
let res4 = A() &amp;&amp; B() &amp;&amp; C();

/* 以下與 res4 等價 */
if(A()) {
  if(B()) {
    C();
  }
}
</code></pre>
<p><code>??</code> 空值合併運算符比較特殊，他會排除nullish(null 或是 undefined)來判斷求值</p>
<pre><code class="language-js">let value1 = 0 || 100; // value = 100
let value2 = 0 ?? 100; // value = 0, 因為 0 不是 nullish
let value3 = null ?? 100; // value = 100
let value4 = undefined ?? 100; // value = 100
let value5 = '' || 'default string' // value = 'default string'
let value6 = '' ?? 'default string' // value = '', 因為 '' 不為 nullish
</code></pre>
<h2 id="-可選鏈式運算子"><a class="header" href="#-可選鏈式運算子">?. 可選鏈式運算子</a></h2>
<p>假設有個函式：</p>
<pre><code class="language-js">async function findOrEmpty() {
  const res = await fetch(urlWithId) // 回傳的結果有可能為 null, 找不到 Id
  // 1. { id, userData: ... }
  // 2. 沒找到, null

  // userData 的格式可能為 { name: string, age: number } 或是忘記填為 null
  // 需要回傳 user 的名字
  return res.userData.name;
}
</code></pre>
<p>上面的函式有個重大錯誤，那就是 res 有可能是 <code>null</code>，那執行 res.userData 相當於存取 <code>null</code> 的 <code>userData</code> 屬性</p>
<p>res.userData 也有可能是 <code>null</code>，導致相當於存取 <code>null</code> 的 <code>name</code> 屬性</p>
<p>這會導致 Error 被擲出，因此需要進行檢查，比方說：</p>
<pre><code class="language-js">async function findOrEmpty() {
  const res = await fetch(urlWithId)
  let name = 'DEFAULT';
  if ( res ) {
    if ( res.userData ) {
      name = res.userData.name
    }
  }
  return name;
}
</code></pre>
<p>學會了短路求值，可以使用：</p>
<pre><code class="language-js">async function findOrEmpty() {
  const res = await fetch(urlWithId)
  let name = 'DEFAULT';
  if( res &amp;&amp; res.userData )
    name = res.userData.name;

  return name;
}
</code></pre>
<p>而 <code>?.</code> 運算子則允許存取一個<code>可能</code>為nullish的數值，並當遇上nullish時，回傳undefined 並且中止求值</p>
<pre><code class="language-js">async function findOrEmpty() {
  const res = await fetch(urlWithId)

  // 如果 res = null，直接回傳 undefine
  // 並中止對 res.userData、res.userData.name 求值
  return res?.userData.name; 
}
</code></pre>
<p>已經知道遇上 nullish 會回傳 undefined，上面使用預設值的寫法可以改成：</p>
<pre><code class="language-js">async function findOrEmpty() {
  const res = await fetch(urlWithId)
  return res?.userData.name ?? 'DEFAULT'; // 使用空值合併運算子，給予初始值
}
</code></pre>
<p>參考 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator">?? operator</a> 和 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/Optional_chaining">Optional chaining</a></p>
<h2 id="陣列"><a class="header" href="#陣列">陣列</a></h2>
<p>在 JavaScript 中，陣列的方法算是極度常用的，這裡只說明幾個常用的 Function：</p>
<p>先假定原始資料：</p>
<pre><code class="language-js">const users = [
  {
    name: 'Peter',
    age: 20,
    salary: 3800
  },
  {
    name: 'Mary',
    age: 22,
    salary: 4000
  },
  {
    name: 'Jason',
    age: 30,
    salary: 8900
  },
  {
    name: 'Benson',
    age: 45,
    salary: 7000
  },
  {
    name: 'Neil',
    age: 35,
    salary: 5200
  },
]
</code></pre>
<p>陣列大部分的參數，都是接受一個簽章為：</p>
<pre><code class="language-js">function callback(element, index, arr) {
  console.log(element, index, arr);
}
</code></pre>
<p>的方法，三個參數分別是</p>
<ul>
<li>當前元素</li>
<li>當前元素索引</li>
<li>原始陣列</li>
</ul>
<h3 id="map-轉換原始陣列變成另外一個陣列"><a class="header" href="#map-轉換原始陣列變成另外一個陣列"><code>map()</code> 轉換原始陣列變成另外一個陣列</a></h3>
<pre><code class="language-js">let data = users.map( e =&gt; {
  return e.salary
});

console.log(data) // [3800,4000,8900,7000,5200]
</code></pre>
<p><strong>Note!</strong> 有個很接近的方法叫做 <code>forEach</code>，但是不建議使用，他算是 for-loop 的callback版本</p>
<pre><code class="language-js">for(let i = 0; i users.length; ++i) {
  console.log(`index = ${i}, value = ${users[i]}`);
}

//等同
users.forEach((e,i) =&gt; {
  console.log(`index = ${i}, value = ${e}`);
})

let data = users.forEach((e,i) =&gt; {
  return e.salary
})

console.log(data) // undefined, forEach不回傳陣列
</code></pre>
<p>因為 <code>forEach</code> 可以被 <code>map</code> 取代，且 <code>forEach</code> 不回傳陣列，因此會有人用來修改原始陣列，比方說</p>
<pre><code class="language-js">users.forEach((e,i, arr) =&gt; {
  arr[i] = e.salary;
})
</code></pre>
<p>這不是一個好做法，因此不推薦使用 <code>forEach</code></p>
<p>此外，早期還未出現展開運算子之前，可以用 <code>map</code> 複製陣列</p>
<pre><code class="language-js">// const data = [...arr]
const data = arr.map(e =&gt; e);
</code></pre>
<h3 id="filter-過濾原始陣列"><a class="header" href="#filter-過濾原始陣列"><code>filter()</code> 過濾原始陣列</a></h3>
<pre><code class="language-js">let data= users.filter((e) =&gt; {
  return e.age &gt; 30; // 必須回傳 boolean 值
})

console.log(data) /* data = [
  {
    name: 'Benson',
    age: 45,
    salary: 7000
  },
  {
    name: 'Neil',
    age: 35,
    salary: 5200
  }
] */
</code></pre>
<h3 id="every-以及-some-判斷所有陣列"><a class="header" href="#every-以及-some-判斷所有陣列"><code>every()</code> 以及 <code>some()</code> 判斷所有陣列</a></h3>
<pre><code class="language-js">const flag1 = users.every(e =&gt; e.salary &gt; 5000) // false, 因為有人薪水不足 5000
const flag2 = users.some(e =&gt; e.salary &gt; 5000) // false, 因為有人超過 5000
</code></pre>
<p><code>every</code> 的概念相當於C++的 <code>all_of</code>(全部符合), <code>some</code> 則是 <code>any_of</code>(任一符合)</p>
<h3 id="sort-進行排序"><a class="header" href="#sort-進行排序"><code>sort</code> 進行排序</a></h3>
<pre><code class="language-js">users.sort((a,b) =&gt; a.age - b.age) // 根據 age 排序
users.sort((a,b) =&gt; a.name.localeCompare(b.name)) // 根據 name 排序
// string 要使用 string.localeCompare 進行比較
</code></pre>
<h3 id="slice-進行分割"><a class="header" href="#slice-進行分割"><code>slice</code> 進行分割</a></h3>
<pre><code class="language-js">// users.slice(startIndex, count)
users.slice(0, 2) // 從index 0 開始，取出兩個元素
</code></pre>
<h3 id="find-傳入條件式尋找元素"><a class="header" href="#find-傳入條件式尋找元素"><code>find</code> 傳入條件式，尋找元素</a></h3>
<pre><code class="language-js">// 因為 find 不一定會找到，建議使用 ?. 來存取物件
const name = users.find(e =&gt; e.age === 22)?.name 
</code></pre>
<p>在實例上，會建議通過一系列的轉換，取出所需要的資料，比方說：</p>
<pre><code class="language-js">const users = [
  {
    name: 'Peter',
    age: 20,
    salary: 3800
  },
  {
    name: 'Mary',
    age: 22,
    salary: 4000
  },
  {
    name: 'Jason',
    age: 30,
    salary: 8900
  },
  {
    name: 'Benson',
    age: 45,
    salary: 7000
  },
  {
    name: 'Neil',
    age: 35,
    salary: 5200
  },
  {
    name: 'Howard',
    age: 44,
    salary: 6666
  },
  {
    name: 'Alex',
    age: 35,
    salary: 7777
  },
]

const salarySigma = users
  .filter(e =&gt; e.salary &gt; 5000)
  .map( e =&gt; e.salary )
  .reduce((sum, currentValue) =&gt; sum + currentValue, 0);

console.log(salarySigma) // 35543
const salaryAvg = salarySigma / users.filter(e =&gt; e.salary &gt; 5000).length // 7108.6
</code></pre>
<p>通過一系列的轉換函式，取出所需要的資料</p>
<blockquote>
<p>絕大部分的 Web 應用，都是處理資料的轉換，因此字串、陣列相關的方法，幾乎是必備的知識</p>
<p>反過來說，雖然也有情況要進行CPU的密集計算，但是該情況還是相對比較少的</p>
</blockquote>
<p>前面提到的用法，幾乎涵蓋大部分陣列的使用情境，但也建議稍微看一下 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String">String.prototype</a> 跟 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp">RegExp.prototype</a> 的資料</p>
<p>其中 RegExp 是 Regular Expression 正規表示法的意思，允許使用模式來匹配字串，舉例來說：</p>
<pre><code class="language-js">// 假定輸入的資料是日期格式，且有可能是 YYYY-MM-DD 或是 YYYY/MM/DD

const date1 = &quot;2001-01-05&quot;;
const date2 = &quot;1998/01/02&quot;;
const rule = /(?&lt;year&gt;[0-9]{0,4})[\-\/](?&lt;month&gt;[0-9]{0,2})[\-\/](?&lt;date&gt;[0-9]{0,2})/;
</code></pre>
<p><img src="sections/js-core/./images/RegExp.png" alt="RegExp" /></p>
<p>這只是一個很小的範例，還有很多種用法，比如說：驗證電子信箱、網址格式、特定的文字輸入...等，且上方的RegExp 是有小瑕疵的(你可以嘗試找出來！)</p>
<p>總之，字串與陣列的處理，涵蓋大部分的操作情境，且額外要注意的事情是：一些 ArrayLike 物件，若有實現迭代器，也是可以輕鬆轉換成陣列的</p>
<p><img src="sections/js-core/./images/NodeList_to_Array.png" alt="n2a" /></p>
<p><code>querySelectorAll</code> 回傳的結果是 <code>NodeList</code>，他並沒有陣列的成員或是屬性，也無法通過 <code>Array.isArray</code> 的測試；</p>
<p>但是經過迭代器展開，或是早期的轉換方式 <code>Array.prototype.slice.call</code> 後，就成為了陣列型別</p>
<p>這些&quot;像是&quot;陣列樣子的物件，被稱作 <code>ArrayLike</code>，除了陣列本身是<code>ArrayLike</code>(因為陣列算是一種特殊的物件，JavaScript沒有真正意義的原生陣列)，還有<code>String</code>也是很經典的例子</p>
<h3 id="json的序列化反序列化"><a class="header" href="#json的序列化反序列化">JSON的序列化/反序列化</a></h3>
<pre><code class="language-js">/* 反序列化 */
const strLikeJson = '{ &quot;a&quot;:100, &quot;b&quot;: 200, &quot;c&quot; :        3000 }';
const object = JSON.parse(strLikeJson);
/** 
 * object { 
 *  a: 100, 
 *  b: 200, 
 *  c: 30000 
 * }
 */

/* 序列化 */
const str = JSON.stringify({ a: 10, b: 20, c: 30 });
// string '{&quot;a&quot;:10,&quot;b&quot;:20,&quot;c&quot;:30}'
</code></pre>
<p>JSON.parse 用來把 JSON 字串轉換為 JS物件，且一定要是 <em>JSON字串</em>，這個說法有一點模糊，看下面的例子</p>
<pre><code class="language-js">const str1 = &quot;{ a: 10, b: 20 }&quot;;
const str2 = &quot;{ a: 10, b: 20, }&quot;;
const str3 = &quot;{ 'a': 10, 'b': 20 }&quot;;
const str4 = &quot;{ \&quot;a\&quot;: 10, \&quot;b\&quot;: 20 }&quot;;
</code></pre>
<p>在上述的例子中，只有 <code>str4</code> 是合法的 JSON字串</p>
<p>JSON.parse 可以接受第二個參數 <code>reviver</code> function，在 parse 解析完字串後，可以進行一些修改：</p>
<pre><code class="language-js">const jsonStr = '{ &quot;a&quot;:100, &quot;b&quot;: 200, &quot;c&quot;: 300 }';
let a = JSON.parse(jsonStr, (key, value) =&gt; {
  console.log(key, value);
  if(typeof value === &quot;number&quot;)
    return value + 50;
  return value; // return origin value
});
// a = { a: 150, b: 250, c: 350 };
</code></pre>
<p>這允許在解析的同時進行一些修改或檢驗，但是要注意，最後一個解析會收到 <code>key</code> 為空字串結果，雖然沒有特別註記，但筆者猜測應該是告知開發者，Parse 結束的情況</p>
<p>如果 <code>reviver</code> 中沒有回傳值為 <code>undefined</code>，則會刪除該屬性：</p>
<pre><code class="language-js">const jsonStr = '{ &quot;a&quot;:100, &quot;b&quot;: 200, &quot;c&quot;: 300 }';
let a = JSON.parse(jsonStr, (key, value) =&gt; {
  switch( key ) {
    case &quot;a&quot;:
    case &quot;b&quot;:
      break;
    default:
      return value;
  }
});
// a = { c: 300 };
</code></pre>
<p>如果當次解析的物件是巢狀的，則由深到淺解析</p>
<pre><code class="language-js">JSON.parse('{&quot;a&quot;:{&quot;b&quot;:{&quot;c&quot;:{&quot;d&quot;:true}}}}', (k,v) =&gt; { console.log(k); return v});
// output: d c b a
</code></pre>
<p><code>JSON.stringify</code> 則是會把物件轉換成對應的 JSON字串，優先調用 <code>toJSON</code> 方法，然後把 <code>可列舉</code> 跟 <code>可序列化</code> 的屬性進行轉換</p>
<ul>
<li>可列舉：PropertyDescriptor 中 enumerable 為 true 的屬性</li>
<li>可序列化：例如 function，就不可進行轉換，通常僅轉換：<code>string</code>, <code>boolean</code>, <code>number</code>；如果屬性是陣列或物件，則深入檢查</li>
</ul>
<p><code>JSON.stringify</code> 可以額外接受兩個參數，第二個參數是 <code>replacer</code>，可以是function 或是 array：</p>
<pre><code class="language-js">const foo = {
  foundation: &quot;Mozilla&quot;,
  model: &quot;box&quot;,
  week: 45,
  transport: &quot;car&quot;,
  month: 7
};

const jsonStr = JSON.stringify(foo, (key, value) =&gt; {
  /* replacer 為 Function 時，如果 return 的值是 undefined, 則忽略該值 */
  if (typeof value === &quot;string&quot;) {
    return undefined;
  }
  return value;
});

// jsonStr = '{&quot;week&quot;:45,&quot;month&quot;:7}'

/* replacer 為 array 時，僅保留對應的key */
const jsonStr2 = JSON.stringify(foo, ['model', 'month', '??']);
// jsonStr = '{&quot;model&quot;:&quot;box&quot;,&quot;month&quot;:7}'

</code></pre>
<p>第三個參數是 <code>space</code> 只是控制縮排而已，例如在輸出文件時，可以使用 <code>JSON.stringify(obj, null, 4)</code> 保留 4個space 的縮排</p>
<h3 id="匿名函數"><a class="header" href="#匿名函數">匿名函數</a></h3>
<p>當調用 Lib 的 function，且內部調用極深時，可以再某個地方使用 <code>function(){}</code> 而不是 <code>() =&gt; {}</code>
這裡使用 <code>setTimeout()</code> 來說明：</p>
<pre><code class="language-js">
setTimeout(function myFn(){
  throw new Error();
}, 0)

/* Error stack:
Uncaught Error
    at myFn (&lt;anonymous&gt;:2:9)
*/

setTimeout(() =&gt; {
  throw new Error();
}, 0)

/* Error stack:
Uncaught Error
    at (&lt;anonymous&gt;:2:9)
*/
</code></pre>
<p>若自己開發Library，或是使用了較深的function invoke，可以加上 <code>function name(){}</code> 來進行除錯，比方說：</p>
<pre><code class="language-js">
lib(function myFn(){
  /* do something */
})


/* Error stack:
Uncaught Error
    at (&lt;anonymous&gt;:2:9)
    at (&lt;anonymous&gt;:2:9)
    at myFn (&lt;anonymous&gt;:2:9) &lt;---- 也許某個部分會原本的函式名稱
    at (&lt;anonymous&gt;:2:9)
    at (&lt;anonymous&gt;:2:9)
    at (&lt;anonymous&gt;:2:9)
    at (&lt;anonymous&gt;:2:9)
    at (&lt;anonymous&gt;:2:9)
*/

// 反之，若使用 arrow function：
lib(() =&gt; {
  /* do something */
})

/* Error stack:
Uncaught Error
    at (&lt;anonymous&gt;:2:9)
    at (&lt;anonymous&gt;:2:9)
    at (&lt;anonymous&gt;:2:9)
    at (&lt;anonymous&gt;:2:9)
    at (&lt;anonymous&gt;:2:9)
    at (&lt;anonymous&gt;:2:9)
    at (&lt;anonymous&gt;:2:9)
    at (&lt;anonymous&gt;:2:9)
會完全遺失錯誤堆疊的資訊
*/
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="結論"><a class="header" href="#結論">結論</a></h1>
<p>這個篇章，快速的把 JS 的基本語法與核心快速地瀏覽一次，這裡簡單統整一下：</p>
<ul>
<li>JavaScript 的基本語法</li>
<li>JavaScript 中的型別系統</li>
<li>早期的物件與現代化的語法</li>
<li>JavaScript 內部引擎的運作機制</li>
<li>非同步程式：Promise與 async/await</li>
<li>常用的函式</li>
</ul>
<p>這裡釐清一個問題，<em>JavaScript Core</em> 到底指的是什麼部份呢？</p>
<p>可以參考 MDN 的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects">Standard Built-in Object</a>，基本上就是 JavaScript 的核心：</p>
<ul>
<li>Infinity、NaN、undefined 等屬性值</li>
<li>Global Function
<ul>
<li>isFinite()</li>
<li>isNaN()</li>
<li>parseFloat()</li>
<li>parseInt()</li>
<li>encodeURI()</li>
<li>encodeURIComponent()</li>
<li>decode()</li>
<li>decodeURIComponent()</li>
</ul>
</li>
<li>Global Object
<ul>
<li>Number</li>
<li>BigInt</li>
<li>Math</li>
<li>Date</li>
<li>String</li>
<li>RegExp</li>
</ul>
</li>
<li>Indexed Collections
<ul>
<li>Array</li>
<li>Typed-Array (參考 MDN，就是限制每個元素幾個位元的陣列，類似C的靜態型別)</li>
</ul>
</li>
<li>Keyed Collections
<ul>
<li>Map、WeakMap</li>
<li>Set、WeakSet</li>
</ul>
</li>
<li>結構化資料
<ul>
<li>JSON</li>
<li>ArrayBuffer、SharedArrayBuffer</li>
<li>Atomics</li>
<li>DataView</li>
</ul>
</li>
<li>控制抽象物件
<ul>
<li>Promise、Generator</li>
</ul>
</li>
<li>Reflection
<ul>
<li>Proxy</li>
<li>Reflect</li>
</ul>
</li>
<li>各種 Error 物件</li>
</ul>
<p>其實常用的，只要注意 <code>Global Object</code> 以及 <code>Array</code>、<code>JSON</code>、<code>Promise</code>，而 <code>ArrayBuffer</code> 如果在處理檔案的上傳或是 WebSocket，也有機會使用到</p>
<h2 id="不屬於-javascript-core-的部份"><a class="header" href="#不屬於-javascript-core-的部份">不屬於 JavaScript Core 的部份</a></h2>
<h3 id="web-api"><a class="header" href="#web-api">Web API</a></h3>
<p>在 Overview 有提到，JavaScript 可以運行在瀏覽器以外的部份(Node.js)，這情況下，通常會當作伺服器運行</p>
<p>而由瀏覽器提供的一系列JavaScript函式或物件，被稱作<a href="https://developer.mozilla.org/en-US/docs/Web/API">Web API</a>，這裡只提出幾個常用的：</p>
<ul>
<li>Window： 一個包含 DOM 文件的視窗，可以說是瀏覽器物件模型(BOM)，得以透過 JavaScript 跟瀏覽器進行互動：
<ul>
<li>history：與瀏覽紀錄的歷史有關</li>
<li>location：當前頁面的網址資訊</li>
<li>screen：目前的視窗資訊</li>
<li>navigator：瀏覽器本身的資訊，像是版本號、運行平台等</li>
</ul>
</li>
<li>Document： 處理 DOM Tree，包含HTML、XML、SVG 等類型；或是像 Cookie 等資料，象徵<code>瀏覽器中載入的網頁</code>資訊</li>
</ul>
<p>實在是有太多部份，例如<code>WebSocket</code>、<code>WebRTC</code>(即時影音通訊)、剪貼簿、事件目標、audio/video 處理模組 ... 等</p>
<h3 id="nodejs"><a class="header" href="#nodejs">Nodejs</a></h3>
<p>相對於 Web API，伺服器端的 JavaScript (<a href="https://nodejs.org/api/">Node.js</a>) 不需要處理瀏覽器相關的資訊，但是可以直接存取系統上的資源：</p>
<ul>
<li>node:crypto：加密/解密模組</li>
<li>node:http：HTTP協定相關模組(發送請求、開啟伺服器等)</li>
<li>node:process：有關目前運行的Process(行程)資訊</li>
<li>node:os：作業系統相關的資訊</li>
<li>node:fs：檔案系統的操作介面</li>
<li>node:net：底層TCP、IPC的操作介面</li>
<li>node :dgram：底層UDP的操作介面</li>
<li>C++ Addons：與C++ Library 交互的一系列操作模組</li>
</ul>
<p>如上所列，Nodejs專注在系統相關的操作，以及如何與 C++ 進行溝通，反而一些通用格式的解析器(如XML、SVG)或是影音模組並沒有提供</p>
<p>所以 JavaScript 其實可以分成兩部份：</p>
<ul>
<li>Standard Object + Web API = 瀏覽器上的JavaScript</li>
<li>Standard Object + Nodejs API = 伺服器端上的JavaScript</li>
</ul>
<p>而 Web API、Nodejs API 這些又被稱為宿主環境(Host Environment)，因為他們是由 Runtime 提供者給予的操作介面</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="legacy-class"><a class="header" href="#legacy-class">Legacy Class</a></h1>
<p>透過 Babel 轉譯的 ES5 Class, 仔細看可以發現許多操作都是基於 <code>Object</code> 下的 descriptor</p>
<pre><code class="language-js">function _typeof(obj) {
  return (
    (_typeof =
      &quot;function&quot; == typeof Symbol &amp;&amp; &quot;symbol&quot; == typeof Symbol.iterator
        ? function (obj) {
            return typeof obj;
          }
        : function (obj) {
            return obj &amp;&amp;
              &quot;function&quot; == typeof Symbol &amp;&amp;
              obj.constructor === Symbol &amp;&amp;
              obj !== Symbol.prototype
              ? &quot;symbol&quot;
              : typeof obj;
          }),
    _typeof(obj)
  );
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== &quot;function&quot; &amp;&amp; superClass !== null) {
    throw new TypeError(&quot;Super expression must either be null or a function&quot;);
  }
  subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, {
    constructor: { value: subClass, writable: true, configurable: true }
  });
  Object.defineProperty(subClass, &quot;prototype&quot;, { writable: false });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf
    ? Object.setPrototypeOf.bind()
    : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call &amp;&amp; (_typeof(call) === &quot;object&quot; || typeof call === &quot;function&quot;)) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError(
      &quot;Derived constructors may only return object or undefined&quot;
    );
  }
  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError(
      &quot;this hasn't been initialised - super() hasn't been called&quot;
    );
  }
  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === &quot;undefined&quot; || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === &quot;function&quot;) return true;
  try {
    Boolean.prototype.valueOf.call(
      Reflect.construct(Boolean, [], function () {})
    );
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf
    ? Object.getPrototypeOf.bind()
    : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
  return _getPrototypeOf(o);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError(&quot;Cannot call a class as a function&quot;);
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i &lt; props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if (&quot;value&quot; in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, &quot;prototype&quot;, { writable: false });
  return Constructor;
}

var Rect = (function () {
  &quot;use strict&quot;;

  function Rect(w, h) {
    _classCallCheck(this, Rect);

    this.w = w;
    this.h = h;
  }

  _createClass(Rect, [
    {
      key: &quot;add&quot;,
      value: function add(r) {
        this.w += r.w;
        this.h += r.h;
      }
    },
    {
      key: &quot;print&quot;,
      value: function print() {
        console.log(this.w + &quot;, &quot; + this.h);
      }
    }
  ]);

  return Rect;
})();

var Square = (function (_Rect) {
  &quot;use strict&quot;;

  _inherits(Square, _Rect);

  var _super = _createSuper(Square);

  function Square(w) {
    _classCallCheck(this, Square);

    return _super.call(this, w, w);
  }

  _createClass(Square, [
    {
      key: &quot;getArea&quot;,
      value: function getArea() {
        return this.w * this.h;
      }
    }
  ]);

  return Square;
})(Rect);
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
